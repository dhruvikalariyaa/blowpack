{"ast":null,"code":"\"use strict\";\n\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultAwsSecurityCredentialsSupplier = void 0;\nconst authclient_1 = require(\"./authclient\");\n/**\n * Internal AWS security credentials supplier implementation used by {@link AwsClient}\n * when a credential source is provided instead of a user defined supplier.\n * The logic is summarized as:\n * 1. If imdsv2_session_token_url is provided in the credential source, then\n *    fetch the aws session token and include it in the headers of the\n *    metadata requests. This is a requirement for IDMSv2 but optional\n *    for IDMSv1.\n * 2. Retrieve AWS region from availability-zone.\n * 3a. Check AWS credentials in environment variables. If not found, get\n *     from security-credentials endpoint.\n * 3b. Get AWS credentials from security-credentials endpoint. In order\n *     to retrieve this, the AWS role needs to be determined by calling\n *     security-credentials endpoint without any argument. Then the\n *     credentials can be retrieved via: security-credentials/role_name\n * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n * 5. Inject x-goog-cloud-target-resource into header and serialize the\n *    signed request. This will be the subject-token to pass to GCP STS.\n */\nclass DefaultAwsSecurityCredentialsSupplier {\n  regionUrl;\n  securityCredentialsUrl;\n  imdsV2SessionTokenUrl;\n  additionalGaxiosOptions;\n  /**\n   * Instantiates a new DefaultAwsSecurityCredentialsSupplier using information\n   * from the credential_source stored in the ADC file.\n   * @param opts The default aws security credentials supplier options object to\n   *   build the supplier with.\n   */\n  constructor(opts) {\n    this.regionUrl = opts.regionUrl;\n    this.securityCredentialsUrl = opts.securityCredentialsUrl;\n    this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;\n    this.additionalGaxiosOptions = opts.additionalGaxiosOptions;\n  }\n  /**\n   * Returns the active AWS region. This first checks to see if the region\n   * is available as an environment variable. If it is not, then the supplier\n   * will call the region URL.\n   * @param context {@link ExternalAccountSupplierContext} from the calling\n   *   {@link AwsClient}, contains the requested audience and subject token type\n   *   for the external account identity.\n   * @return A promise that resolves with the AWS region string.\n   */\n  async getAwsRegion(context) {\n    // Priority order for region determination:\n    // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n    if (this.#regionFromEnv) {\n      return this.#regionFromEnv;\n    }\n    const metadataHeaders = new Headers();\n    if (!this.#regionFromEnv && this.imdsV2SessionTokenUrl) {\n      metadataHeaders.set('x-aws-ec2-metadata-token', await this.#getImdsV2SessionToken(context.transporter));\n    }\n    if (!this.regionUrl) {\n      throw new RangeError('Unable to determine AWS region due to missing ' + '\"options.credential_source.region_url\"');\n    }\n    const opts = {\n      ...this.additionalGaxiosOptions,\n      url: this.regionUrl,\n      method: 'GET',\n      headers: metadataHeaders\n    };\n    authclient_1.AuthClient.setMethodName(opts, 'getAwsRegion');\n    const response = await context.transporter.request(opts);\n    // Remove last character. For example, if us-east-2b is returned,\n    // the region would be us-east-2.\n    return response.data.substr(0, response.data.length - 1);\n  }\n  /**\n   * Returns AWS security credentials. This first checks to see if the credentials\n   * is available as environment variables. If it is not, then the supplier\n   * will call the security credentials URL.\n   * @param context {@link ExternalAccountSupplierContext} from the calling\n   *   {@link AwsClient}, contains the requested audience and subject token type\n   *   for the external account identity.\n   * @return A promise that resolves with the AWS security credentials.\n   */\n  async getAwsSecurityCredentials(context) {\n    // Check environment variables for permanent credentials first.\n    // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n    if (this.#securityCredentialsFromEnv) {\n      return this.#securityCredentialsFromEnv;\n    }\n    const metadataHeaders = new Headers();\n    if (this.imdsV2SessionTokenUrl) {\n      metadataHeaders.set('x-aws-ec2-metadata-token', await this.#getImdsV2SessionToken(context.transporter));\n    }\n    // Since the role on a VM can change, we don't need to cache it.\n    const roleName = await this.#getAwsRoleName(metadataHeaders, context.transporter);\n    // Temporary credentials typically last for several hours.\n    // Expiration is returned in response.\n    // Consider future optimization of this logic to cache AWS tokens\n    // until their natural expiration.\n    const awsCreds = await this.#retrieveAwsSecurityCredentials(roleName, metadataHeaders, context.transporter);\n    return {\n      accessKeyId: awsCreds.AccessKeyId,\n      secretAccessKey: awsCreds.SecretAccessKey,\n      token: awsCreds.Token\n    };\n  }\n  /**\n   * @param transporter The transporter to use for requests.\n   * @return A promise that resolves with the IMDSv2 Session Token.\n   */\n  async #getImdsV2SessionToken(transporter) {\n    const opts = {\n      ...this.additionalGaxiosOptions,\n      url: this.imdsV2SessionTokenUrl,\n      method: 'PUT',\n      headers: {\n        'x-aws-ec2-metadata-token-ttl-seconds': '300'\n      }\n    };\n    authclient_1.AuthClient.setMethodName(opts, '#getImdsV2SessionToken');\n    const response = await transporter.request(opts);\n    return response.data;\n  }\n  /**\n   * @param headers The headers to be used in the metadata request.\n   * @param transporter The transporter to use for requests.\n   * @return A promise that resolves with the assigned role to the current\n   *   AWS VM. This is needed for calling the security-credentials endpoint.\n   */\n  async #getAwsRoleName(headers, transporter) {\n    if (!this.securityCredentialsUrl) {\n      throw new Error('Unable to determine AWS role name due to missing ' + '\"options.credential_source.url\"');\n    }\n    const opts = {\n      ...this.additionalGaxiosOptions,\n      url: this.securityCredentialsUrl,\n      method: 'GET',\n      headers: headers\n    };\n    authclient_1.AuthClient.setMethodName(opts, '#getAwsRoleName');\n    const response = await transporter.request(opts);\n    return response.data;\n  }\n  /**\n   * Retrieves the temporary AWS credentials by calling the security-credentials\n   * endpoint as specified in the `credential_source` object.\n   * @param roleName The role attached to the current VM.\n   * @param headers The headers to be used in the metadata request.\n   * @param transporter The transporter to use for requests.\n   * @return A promise that resolves with the temporary AWS credentials\n   *   needed for creating the GetCallerIdentity signed request.\n   */\n  async #retrieveAwsSecurityCredentials(roleName, headers, transporter) {\n    const opts = {\n      ...this.additionalGaxiosOptions,\n      url: `${this.securityCredentialsUrl}/${roleName}`,\n      headers: headers\n    };\n    authclient_1.AuthClient.setMethodName(opts, '#retrieveAwsSecurityCredentials');\n    const response = await transporter.request(opts);\n    return response.data;\n  }\n  get #regionFromEnv() {\n    // The AWS region can be provided through AWS_REGION or AWS_DEFAULT_REGION.\n    // Only one is required.\n    return process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION'] || null;\n  }\n  get #securityCredentialsFromEnv() {\n    // Both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required.\n    if (process.env['AWS_ACCESS_KEY_ID'] && process.env['AWS_SECRET_ACCESS_KEY']) {\n      return {\n        accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n        secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n        token: process.env['AWS_SESSION_TOKEN']\n      };\n    }\n    return null;\n  }\n}\nexports.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;","map":{"version":3,"names":["Object","defineProperty","exports","value","DefaultAwsSecurityCredentialsSupplier","authclient_1","require","regionUrl","securityCredentialsUrl","imdsV2SessionTokenUrl","additionalGaxiosOptions","constructor","opts","getAwsRegion","context","regionFromEnv","metadataHeaders","Headers","set","getImdsV2SessionToken","transporter","RangeError","url","method","headers","AuthClient","setMethodName","response","request","data","substr","length","getAwsSecurityCredentials","securityCredentialsFromEnv","roleName","getAwsRoleName","awsCreds","retrieveAwsSecurityCredentials","accessKeyId","AccessKeyId","secretAccessKey","SecretAccessKey","token","Token","#getImdsV2SessionToken","#getAwsRoleName","Error","#retrieveAwsSecurityCredentials","#regionFromEnv","process","env","#securityCredentialsFromEnv"],"sources":["E:/blowpack/frountend/node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js"],"sourcesContent":["\"use strict\";\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultAwsSecurityCredentialsSupplier = void 0;\nconst authclient_1 = require(\"./authclient\");\n/**\n * Internal AWS security credentials supplier implementation used by {@link AwsClient}\n * when a credential source is provided instead of a user defined supplier.\n * The logic is summarized as:\n * 1. If imdsv2_session_token_url is provided in the credential source, then\n *    fetch the aws session token and include it in the headers of the\n *    metadata requests. This is a requirement for IDMSv2 but optional\n *    for IDMSv1.\n * 2. Retrieve AWS region from availability-zone.\n * 3a. Check AWS credentials in environment variables. If not found, get\n *     from security-credentials endpoint.\n * 3b. Get AWS credentials from security-credentials endpoint. In order\n *     to retrieve this, the AWS role needs to be determined by calling\n *     security-credentials endpoint without any argument. Then the\n *     credentials can be retrieved via: security-credentials/role_name\n * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n * 5. Inject x-goog-cloud-target-resource into header and serialize the\n *    signed request. This will be the subject-token to pass to GCP STS.\n */\nclass DefaultAwsSecurityCredentialsSupplier {\n    regionUrl;\n    securityCredentialsUrl;\n    imdsV2SessionTokenUrl;\n    additionalGaxiosOptions;\n    /**\n     * Instantiates a new DefaultAwsSecurityCredentialsSupplier using information\n     * from the credential_source stored in the ADC file.\n     * @param opts The default aws security credentials supplier options object to\n     *   build the supplier with.\n     */\n    constructor(opts) {\n        this.regionUrl = opts.regionUrl;\n        this.securityCredentialsUrl = opts.securityCredentialsUrl;\n        this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;\n        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;\n    }\n    /**\n     * Returns the active AWS region. This first checks to see if the region\n     * is available as an environment variable. If it is not, then the supplier\n     * will call the region URL.\n     * @param context {@link ExternalAccountSupplierContext} from the calling\n     *   {@link AwsClient}, contains the requested audience and subject token type\n     *   for the external account identity.\n     * @return A promise that resolves with the AWS region string.\n     */\n    async getAwsRegion(context) {\n        // Priority order for region determination:\n        // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n        if (this.#regionFromEnv) {\n            return this.#regionFromEnv;\n        }\n        const metadataHeaders = new Headers();\n        if (!this.#regionFromEnv && this.imdsV2SessionTokenUrl) {\n            metadataHeaders.set('x-aws-ec2-metadata-token', await this.#getImdsV2SessionToken(context.transporter));\n        }\n        if (!this.regionUrl) {\n            throw new RangeError('Unable to determine AWS region due to missing ' +\n                '\"options.credential_source.region_url\"');\n        }\n        const opts = {\n            ...this.additionalGaxiosOptions,\n            url: this.regionUrl,\n            method: 'GET',\n            headers: metadataHeaders,\n        };\n        authclient_1.AuthClient.setMethodName(opts, 'getAwsRegion');\n        const response = await context.transporter.request(opts);\n        // Remove last character. For example, if us-east-2b is returned,\n        // the region would be us-east-2.\n        return response.data.substr(0, response.data.length - 1);\n    }\n    /**\n     * Returns AWS security credentials. This first checks to see if the credentials\n     * is available as environment variables. If it is not, then the supplier\n     * will call the security credentials URL.\n     * @param context {@link ExternalAccountSupplierContext} from the calling\n     *   {@link AwsClient}, contains the requested audience and subject token type\n     *   for the external account identity.\n     * @return A promise that resolves with the AWS security credentials.\n     */\n    async getAwsSecurityCredentials(context) {\n        // Check environment variables for permanent credentials first.\n        // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n        if (this.#securityCredentialsFromEnv) {\n            return this.#securityCredentialsFromEnv;\n        }\n        const metadataHeaders = new Headers();\n        if (this.imdsV2SessionTokenUrl) {\n            metadataHeaders.set('x-aws-ec2-metadata-token', await this.#getImdsV2SessionToken(context.transporter));\n        }\n        // Since the role on a VM can change, we don't need to cache it.\n        const roleName = await this.#getAwsRoleName(metadataHeaders, context.transporter);\n        // Temporary credentials typically last for several hours.\n        // Expiration is returned in response.\n        // Consider future optimization of this logic to cache AWS tokens\n        // until their natural expiration.\n        const awsCreds = await this.#retrieveAwsSecurityCredentials(roleName, metadataHeaders, context.transporter);\n        return {\n            accessKeyId: awsCreds.AccessKeyId,\n            secretAccessKey: awsCreds.SecretAccessKey,\n            token: awsCreds.Token,\n        };\n    }\n    /**\n     * @param transporter The transporter to use for requests.\n     * @return A promise that resolves with the IMDSv2 Session Token.\n     */\n    async #getImdsV2SessionToken(transporter) {\n        const opts = {\n            ...this.additionalGaxiosOptions,\n            url: this.imdsV2SessionTokenUrl,\n            method: 'PUT',\n            headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '300' },\n        };\n        authclient_1.AuthClient.setMethodName(opts, '#getImdsV2SessionToken');\n        const response = await transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @param transporter The transporter to use for requests.\n     * @return A promise that resolves with the assigned role to the current\n     *   AWS VM. This is needed for calling the security-credentials endpoint.\n     */\n    async #getAwsRoleName(headers, transporter) {\n        if (!this.securityCredentialsUrl) {\n            throw new Error('Unable to determine AWS role name due to missing ' +\n                '\"options.credential_source.url\"');\n        }\n        const opts = {\n            ...this.additionalGaxiosOptions,\n            url: this.securityCredentialsUrl,\n            method: 'GET',\n            headers: headers,\n        };\n        authclient_1.AuthClient.setMethodName(opts, '#getAwsRoleName');\n        const response = await transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * Retrieves the temporary AWS credentials by calling the security-credentials\n     * endpoint as specified in the `credential_source` object.\n     * @param roleName The role attached to the current VM.\n     * @param headers The headers to be used in the metadata request.\n     * @param transporter The transporter to use for requests.\n     * @return A promise that resolves with the temporary AWS credentials\n     *   needed for creating the GetCallerIdentity signed request.\n     */\n    async #retrieveAwsSecurityCredentials(roleName, headers, transporter) {\n        const opts = {\n            ...this.additionalGaxiosOptions,\n            url: `${this.securityCredentialsUrl}/${roleName}`,\n            headers: headers,\n        };\n        authclient_1.AuthClient.setMethodName(opts, '#retrieveAwsSecurityCredentials');\n        const response = await transporter.request(opts);\n        return response.data;\n    }\n    get #regionFromEnv() {\n        // The AWS region can be provided through AWS_REGION or AWS_DEFAULT_REGION.\n        // Only one is required.\n        return (process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION'] || null);\n    }\n    get #securityCredentialsFromEnv() {\n        // Both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required.\n        if (process.env['AWS_ACCESS_KEY_ID'] &&\n            process.env['AWS_SECRET_ACCESS_KEY']) {\n            return {\n                accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n                secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n                token: process.env['AWS_SESSION_TOKEN'],\n            };\n        }\n        return null;\n    }\n}\nexports.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;\n//# sourceMappingURL=defaultawssecuritycredentialssupplier.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}