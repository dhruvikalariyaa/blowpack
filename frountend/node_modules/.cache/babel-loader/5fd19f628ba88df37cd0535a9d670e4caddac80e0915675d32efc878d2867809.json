{"ast":null,"code":"\"use strict\";\n\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OAuth2Client = exports.ClientAuthentication = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = require(\"gaxios\");\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\nconst util_1 = require(\"../util\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));\n/**\n * The client authentication type. Supported values are basic, post, and none.\n * https://datatracker.ietf.org/doc/html/rfc7591#section-2\n */\nvar ClientAuthentication;\n(function (ClientAuthentication) {\n  ClientAuthentication[\"ClientSecretPost\"] = \"ClientSecretPost\";\n  ClientAuthentication[\"ClientSecretBasic\"] = \"ClientSecretBasic\";\n  ClientAuthentication[\"None\"] = \"None\";\n})(ClientAuthentication || (exports.ClientAuthentication = ClientAuthentication = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n  redirectUri;\n  certificateCache = {};\n  certificateExpiry = null;\n  certificateCacheFormat = CertificateFormat.PEM;\n  refreshTokenPromises = new Map();\n  endpoints;\n  issuers;\n  clientAuthentication;\n  // TODO: refactor tests to make this private\n  _clientId;\n  // TODO: refactor tests to make this private\n  _clientSecret;\n  refreshHandler;\n  /**\n   * An OAuth2 Client for Google APIs.\n   *\n   * @param options The OAuth2 Client Options. Passing an `clientId` directly is **@DEPRECATED**.\n   * @param clientSecret **@DEPRECATED**. Provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead.\n   * @param redirectUri **@DEPRECATED**. Provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead.\n   */\n  constructor(options = {},\n  /**\n   * @deprecated - provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead\n   */\n  clientSecret,\n  /**\n   * @deprecated - provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead\n   */\n  redirectUri) {\n    super(typeof options === 'object' ? options : {});\n    if (typeof options !== 'object') {\n      options = {\n        clientId: options,\n        clientSecret,\n        redirectUri\n      };\n    }\n    this._clientId = options.clientId || options.client_id;\n    this._clientSecret = options.clientSecret || options.client_secret;\n    this.redirectUri = options.redirectUri || options.redirect_uris?.[0];\n    this.endpoints = {\n      tokenInfoUrl: 'https://oauth2.googleapis.com/tokeninfo',\n      oauth2AuthBaseUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n      oauth2TokenUrl: 'https://oauth2.googleapis.com/token',\n      oauth2RevokeUrl: 'https://oauth2.googleapis.com/revoke',\n      oauth2FederatedSignonPemCertsUrl: 'https://www.googleapis.com/oauth2/v1/certs',\n      oauth2FederatedSignonJwkCertsUrl: 'https://www.googleapis.com/oauth2/v3/certs',\n      oauth2IapPublicKeyUrl: 'https://www.gstatic.com/iap/verify/public_key',\n      ...options.endpoints\n    };\n    this.clientAuthentication = options.clientAuthentication || ClientAuthentication.ClientSecretPost;\n    this.issuers = options.issuers || ['accounts.google.com', 'https://accounts.google.com', this.universeDomain];\n  }\n  /**\n   * @deprecated use instance's {@link OAuth2Client.endpoints}\n   */\n  static GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  static CLOCK_SKEW_SECS_ = 300;\n  /**\n   * The default max Token Lifetime is one day in seconds\n   */\n  static DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (Array.isArray(opts.scope)) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n  generateCodeVerifier() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n  }\n  /**\n   * Convenience method to automatically generate a code_verifier, and its\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   *\n   * For a full example see:\n   * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n   */\n  async generateCodeVerifierAsync() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const crypto = (0, crypto_1.createCrypto)();\n    const randomString = crypto.randomBytesBase64(96);\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n    return {\n      codeVerifier,\n      codeChallenge\n    };\n  }\n  getToken(codeOrOptions, callback) {\n    const options = typeof codeOrOptions === 'string' ? {\n      code: codeOrOptions\n    } : codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n  async getTokenAsync(options) {\n    const url = this.endpoints.oauth2TokenUrl.toString();\n    const headers = new Headers();\n    const values = {\n      client_id: options.client_id || this._clientId,\n      code_verifier: options.codeVerifier,\n      code: options.code,\n      grant_type: 'authorization_code',\n      redirect_uri: options.redirect_uri || this.redirectUri\n    };\n    if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {\n      const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);\n      headers.set('authorization', `Basic ${basic.toString('base64')}`);\n    }\n    if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) {\n      values.client_secret = this._clientSecret;\n    }\n    const opts = {\n      ...OAuth2Client.RETRY_CONFIG,\n      method: 'POST',\n      url,\n      data: new URLSearchParams((0, util_1.removeUndefinedValuesInObject)(values)),\n      headers\n    };\n    authclient_1.AuthClient.setMethodName(opts, 'getTokenAsync');\n    const res = await this.transporter.request(opts);\n    const tokens = res.data;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {\n      tokens,\n      res\n    };\n  }\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  async refreshToken(refreshToken) {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken);\n    }\n    const p = this.refreshTokenNoCache(refreshToken).then(r => {\n      this.refreshTokenPromises.delete(refreshToken);\n      return r;\n    }, e => {\n      this.refreshTokenPromises.delete(refreshToken);\n      throw e;\n    });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n  async refreshTokenNoCache(refreshToken) {\n    if (!refreshToken) {\n      throw new Error('No refresh token is set.');\n    }\n    const url = this.endpoints.oauth2TokenUrl.toString();\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n    let res;\n    try {\n      const opts = {\n        ...OAuth2Client.RETRY_CONFIG,\n        method: 'POST',\n        url,\n        data: new URLSearchParams((0, util_1.removeUndefinedValuesInObject)(data))\n      };\n      authclient_1.AuthClient.setMethodName(opts, 'refreshTokenNoCache');\n      // request for new token\n      res = await this.transporter.request(opts);\n    } catch (e) {\n      if (e instanceof gaxios_1.GaxiosError && e.message === 'invalid_grant' && e.response?.data && /ReAuth/i.test(e.response.data.error_description)) {\n        e.message = JSON.stringify(e.response.data);\n      }\n      throw e;\n    }\n    const tokens = res.data;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {\n      tokens,\n      res\n    };\n  }\n  refreshAccessToken(callback) {\n    if (callback) {\n      this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n  async refreshAccessTokenAsync() {\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {\n      credentials: this.credentials,\n      res: r.res\n    };\n  }\n  getAccessToken(callback) {\n    if (callback) {\n      this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n  async getAccessTokenAsync() {\n    const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh) {\n      if (!this.credentials.refresh_token) {\n        if (this.refreshHandler) {\n          const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n          if (refreshedAccessToken?.access_token) {\n            this.setCredentials(refreshedAccessToken);\n            return {\n              token: this.credentials.access_token\n            };\n          }\n        } else {\n          throw new Error('No refresh token or refresh handler callback is set.');\n        }\n      }\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || r.credentials && !r.credentials.access_token) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {\n        token: r.credentials.access_token,\n        res: r.res\n      };\n    } else {\n      return {\n        token: this.credentials.access_token\n      };\n    }\n  }\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { authorization: 'Bearer <access_token_value>' }\n   */\n  async getRequestHeaders(url) {\n    const headers = (await this.getRequestMetadataAsync(url)).headers;\n    return headers;\n  }\n  async getRequestMetadataAsync(url) {\n    url;\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) {\n      throw new Error('No access, refresh token, API key or refresh handler callback is set.');\n    }\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = new Headers({\n        authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      });\n      return {\n        headers: this.addSharedMetadataHeaders(headers)\n      };\n    }\n    // If refreshHandler exists, call processAndValidateRefreshHandler().\n    if (this.refreshHandler) {\n      const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n      if (refreshedAccessToken?.access_token) {\n        this.setCredentials(refreshedAccessToken);\n        const headers = new Headers({\n          authorization: 'Bearer ' + this.credentials.access_token\n        });\n        return {\n          headers: this.addSharedMetadataHeaders(headers)\n        };\n      }\n    }\n    if (this.apiKey) {\n      return {\n        headers: new Headers({\n          'X-Goog-Api-Key': this.apiKey\n        })\n      };\n    }\n    let r = null;\n    let tokens = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err;\n      if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n        e.message = `Could not refresh access token: ${e.message}`;\n      }\n      throw e;\n    }\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = new Headers({\n      authorization: credentials.token_type + ' ' + tokens.access_token\n    });\n    return {\n      headers: this.addSharedMetadataHeaders(headers),\n      res: r.res\n    };\n  }\n  /**\n   * Generates an URL to revoke the given token.\n   * @param token The existing token to be revoked.\n   *\n   * @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}\n   */\n  static getRevokeTokenUrl(token) {\n    return new OAuth2Client().getRevokeTokenURL(token).toString();\n  }\n  /**\n   * Generates a URL to revoke the given token.\n   *\n   * @param token The existing token to be revoked.\n   */\n  getRevokeTokenURL(token) {\n    const url = new URL(this.endpoints.oauth2RevokeUrl);\n    url.searchParams.append('token', token);\n    return url;\n  }\n  revokeToken(token, callback) {\n    const opts = {\n      ...OAuth2Client.RETRY_CONFIG,\n      url: this.getRevokeTokenURL(token).toString(),\n      method: 'POST'\n    };\n    authclient_1.AuthClient.setMethodName(opts, 'revokeToken');\n    if (callback) {\n      this.transporter.request(opts).then(r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n  revokeCredentials(callback) {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n  async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  async requestAsync(opts, reAuthRetried = false) {\n    try {\n      const r = await this.getRequestMetadataAsync();\n      opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);\n      this.addUserProjectAndAuthHeaders(opts.headers, r.headers);\n      if (this.apiKey) {\n        opts.headers.set('X-Goog-Api-Key', this.apiKey);\n      }\n      return await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but either no\n        //   expiry_date was available or the forceRefreshOnFailure flag is set.\n        //   The absent expiry_date case can happen when developers stash the\n        //   access_token and refresh_token for later use, but the access_token\n        //   fails on the first try because it's expired. Some developers may\n        //   choose to enable forceRefreshOnFailure to mitigate time-related\n        //   errors.\n        // Or the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - No refresh_token was available\n        // - An access_token and a refreshHandler callback were available, but\n        //   either no expiry_date was available or the forceRefreshOnFailure\n        //   flag is set. The access_token fails on the first try because it's\n        //   expired. Some developers may choose to enable forceRefreshOnFailure\n        //   to mitigate time-related errors.\n        const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n        const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        } else if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {\n          const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n          if (refreshedAccessToken?.access_token) {\n            this.setCredentials(refreshedAccessToken);\n          }\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n  }\n  verifyIdToken(options, callback) {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n  async verifyIdTokenAsync(options) {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);\n    return login;\n  }\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken) {\n    const {\n      data\n    } = await this.transporter.request({\n      ...OAuth2Client.RETRY_CONFIG,\n      method: 'POST',\n      headers: {\n        'content-type': 'application/x-www-form-urlencoded;charset=UTF-8',\n        authorization: `Bearer ${accessToken}`\n      },\n      url: this.endpoints.tokenInfoUrl.toString()\n    });\n    const info = Object.assign({\n      expiry_date: new Date().getTime() + data.expires_in * 1000,\n      scopes: data.scope.split(' ')\n    }, data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n  getFederatedSignonCerts(callback) {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n  async getFederatedSignonCertsAsync() {\n    const nowTime = new Date().getTime();\n    const format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;\n    if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {\n      return {\n        certs: this.certificateCache,\n        format\n      };\n    }\n    let res;\n    let url;\n    switch (format) {\n      case CertificateFormat.PEM:\n        url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();\n        break;\n      case CertificateFormat.JWK:\n        url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();\n        break;\n      default:\n        throw new Error(`Unsupported certificate format ${format}`);\n    }\n    try {\n      const opts = {\n        ...OAuth2Client.RETRY_CONFIG,\n        url\n      };\n      authclient_1.AuthClient.setMethodName(opts, 'getFederatedSignonCertsAsync');\n      res = await this.transporter.request(opts);\n    } catch (e) {\n      if (e instanceof Error) {\n        e.message = `Failed to retrieve verification certificates: ${e.message}`;\n      }\n      throw e;\n    }\n    const cacheControl = res?.headers.get('cache-control');\n    let cacheAge = -1;\n    if (cacheControl) {\n      const maxAge = /max-age=(?<maxAge>[0-9]+)/.exec(cacheControl)?.groups?.maxAge;\n      if (maxAge) {\n        // Cache results with max-age (in seconds)\n        cacheAge = Number(maxAge) * 1000; // milliseconds\n      }\n    }\n    let certificates = {};\n    switch (format) {\n      case CertificateFormat.PEM:\n        certificates = res.data;\n        break;\n      case CertificateFormat.JWK:\n        for (const key of res.data.keys) {\n          certificates[key.kid] = key;\n        }\n        break;\n      default:\n        throw new Error(`Unsupported certificate format ${format}`);\n    }\n    const now = new Date();\n    this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n    this.certificateCache = certificates;\n    this.certificateCacheFormat = format;\n    return {\n      certs: certificates,\n      format,\n      res\n    };\n  }\n  getIapPublicKeys(callback) {\n    if (callback) {\n      this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n    } else {\n      return this.getIapPublicKeysAsync();\n    }\n  }\n  async getIapPublicKeysAsync() {\n    let res;\n    const url = this.endpoints.oauth2IapPublicKeyUrl.toString();\n    try {\n      const opts = {\n        ...OAuth2Client.RETRY_CONFIG,\n        url\n      };\n      authclient_1.AuthClient.setMethodName(opts, 'getIapPublicKeysAsync');\n      res = await this.transporter.request(opts);\n    } catch (e) {\n      if (e instanceof Error) {\n        e.message = `Failed to retrieve verification certificates: ${e.message}`;\n      }\n      throw e;\n    }\n    return {\n      pubkeys: res.data,\n      res\n    };\n  }\n  verifySignedJwtWithCerts() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n  }\n  /**\n   * Verify the id token is signed with the correct certificate\n   * and is from the correct audience.\n   * @param jwt The jwt to verify (The ID Token in this case).\n   * @param certs The array of certs to test the jwt against.\n   * @param requiredAudience The audience to test the jwt against.\n   * @param issuers The allowed issuers of the jwt (Optional).\n   * @param maxExpiry The max expiry the certificate can be (Optional).\n   * @return Returns a promise resolving to LoginTicket on verification.\n   */\n  async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n    const crypto = (0, crypto_1.createCrypto)();\n    if (!maxExpiry) {\n      maxExpiry = OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;\n    }\n    const segments = jwt.split('.');\n    if (segments.length !== 3) {\n      throw new Error('Wrong number of segments in token: ' + jwt);\n    }\n    const signed = segments[0] + '.' + segments[1];\n    let signature = segments[2];\n    let envelope;\n    let payload;\n    try {\n      envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n    } catch (err) {\n      if (err instanceof Error) {\n        err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n      }\n      throw err;\n    }\n    if (!envelope) {\n      throw new Error(\"Can't parse token envelope: \" + segments[0]);\n    }\n    try {\n      payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n    } catch (err) {\n      if (err instanceof Error) {\n        err.message = `Can't parse token payload '${segments[0]}`;\n      }\n      throw err;\n    }\n    if (!payload) {\n      throw new Error(\"Can't parse token payload: \" + segments[1]);\n    }\n    if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n      // If this is not present, then there's no reason to attempt verification\n      throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n    }\n    const cert = certs[envelope.kid];\n    if (envelope.alg === 'ES256') {\n      signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n    }\n    const verified = await crypto.verify(cert, signed, signature);\n    if (!verified) {\n      throw new Error('Invalid token signature: ' + jwt);\n    }\n    if (!payload.iat) {\n      throw new Error('No issue time in token: ' + JSON.stringify(payload));\n    }\n    if (!payload.exp) {\n      throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n    }\n    const iat = Number(payload.iat);\n    if (isNaN(iat)) throw new Error('iat field using invalid format');\n    const exp = Number(payload.exp);\n    if (isNaN(exp)) throw new Error('exp field using invalid format');\n    const now = new Date().getTime() / 1000;\n    if (exp >= now + maxExpiry) {\n      throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n    if (now < earliest) {\n      throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n    }\n    if (now > latest) {\n      throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n    }\n    if (issuers && issuers.indexOf(payload.iss) < 0) {\n      throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n    }\n    // Check the audience matches if we have one\n    if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n      const aud = payload.aud;\n      let audVerified = false;\n      // If the requiredAudience is an array, check if it contains token\n      // audience\n      if (requiredAudience.constructor === Array) {\n        audVerified = requiredAudience.indexOf(aud) > -1;\n      } else {\n        audVerified = aud === requiredAudience;\n      }\n      if (!audVerified) {\n        throw new Error('Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new loginticket_1.LoginTicket(envelope, payload);\n  }\n  /**\n   * Returns a promise that resolves with AccessTokenResponse type if\n   * refreshHandler is defined.\n   * If not, nothing is returned.\n   */\n  async processAndValidateRefreshHandler() {\n    if (this.refreshHandler) {\n      const accessTokenResponse = await this.refreshHandler();\n      if (!accessTokenResponse.access_token) {\n        throw new Error('No access token is returned by the refreshHandler callback.');\n      }\n      return accessTokenResponse;\n    }\n    return;\n  }\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  isTokenExpiring() {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n  }\n}\nexports.OAuth2Client = OAuth2Client;","map":{"version":3,"names":["Object","defineProperty","exports","value","OAuth2Client","ClientAuthentication","CertificateFormat","CodeChallengeMethod","gaxios_1","require","querystring","stream","formatEcdsa","util_1","crypto_1","authclient_1","loginticket_1","AuthClient","redirectUri","certificateCache","certificateExpiry","certificateCacheFormat","PEM","refreshTokenPromises","Map","endpoints","issuers","clientAuthentication","_clientId","_clientSecret","refreshHandler","constructor","options","clientSecret","clientId","client_id","client_secret","redirect_uris","tokenInfoUrl","oauth2AuthBaseUrl","oauth2TokenUrl","oauth2RevokeUrl","oauth2FederatedSignonPemCertsUrl","oauth2FederatedSignonJwkCertsUrl","oauth2IapPublicKeyUrl","ClientSecretPost","universeDomain","GOOGLE_TOKEN_INFO_URL","CLOCK_SKEW_SECS_","DEFAULT_MAX_TOKEN_LIFETIME_SECS_","generateAuthUrl","opts","code_challenge_method","code_challenge","Error","response_type","redirect_uri","Array","isArray","scope","join","rootUrl","toString","stringify","generateCodeVerifier","generateCodeVerifierAsync","crypto","createCrypto","randomString","randomBytesBase64","codeVerifier","replace","unencodedCodeChallenge","sha256DigestBase64","codeChallenge","split","getToken","codeOrOptions","callback","code","getTokenAsync","then","r","tokens","res","e","response","url","headers","Headers","values","code_verifier","grant_type","ClientSecretBasic","basic","Buffer","from","set","RETRY_CONFIG","method","data","URLSearchParams","removeUndefinedValuesInObject","setMethodName","transporter","request","expires_in","expiry_date","Date","getTime","emit","refreshToken","refreshTokenNoCache","has","get","p","delete","refresh_token","GaxiosError","message","test","error_description","JSON","refreshAccessToken","refreshAccessTokenAsync","credentials","getAccessToken","getAccessTokenAsync","token","shouldRefresh","access_token","isTokenExpiring","refreshedAccessToken","processAndValidateRefreshHandler","setCredentials","getRequestHeaders","getRequestMetadataAsync","thisCreds","apiKey","token_type","authorization","addSharedMetadataHeaders","err","status","getRevokeTokenUrl","getRevokeTokenURL","URL","searchParams","append","revokeToken","revokeCredentials","revokeCredentialsAsync","requestAsync","reAuthRetried","Gaxios","mergeHeaders","addUserProjectAndAuthHeaders","statusCode","mayRequireRefresh","forceRefreshOnFailure","mayRequireRefreshWithNoRefreshToken","isReadableStream","config","Readable","isAuthErr","verifyIdToken","verifyIdTokenAsync","idToken","getFederatedSignonCertsAsync","login","verifySignedJwtWithCertsAsync","certs","audience","maxExpiry","getTokenInfo","accessToken","info","assign","scopes","getFederatedSignonCerts","nowTime","format","hasBrowserCrypto","JWK","cacheControl","cacheAge","maxAge","exec","groups","Number","certificates","key","keys","kid","now","getIapPublicKeys","getIapPublicKeysAsync","pubkeys","verifySignedJwtWithCerts","jwt","requiredAudience","segments","length","signed","signature","envelope","payload","parse","decodeBase64StringUtf8","prototype","hasOwnProperty","call","cert","alg","joseToDer","verified","verify","iat","exp","isNaN","earliest","latest","indexOf","iss","aud","audVerified","LoginTicket","accessTokenResponse","expiryDate","eagerRefreshThresholdMillis"],"sources":["E:/blowpack/frountend/node_modules/google-auth-library/build/src/auth/oauth2client.js"],"sourcesContent":["\"use strict\";\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OAuth2Client = exports.ClientAuthentication = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = require(\"gaxios\");\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\nconst util_1 = require(\"../util\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));\n/**\n * The client authentication type. Supported values are basic, post, and none.\n * https://datatracker.ietf.org/doc/html/rfc7591#section-2\n */\nvar ClientAuthentication;\n(function (ClientAuthentication) {\n    ClientAuthentication[\"ClientSecretPost\"] = \"ClientSecretPost\";\n    ClientAuthentication[\"ClientSecretBasic\"] = \"ClientSecretBasic\";\n    ClientAuthentication[\"None\"] = \"None\";\n})(ClientAuthentication || (exports.ClientAuthentication = ClientAuthentication = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    redirectUri;\n    certificateCache = {};\n    certificateExpiry = null;\n    certificateCacheFormat = CertificateFormat.PEM;\n    refreshTokenPromises = new Map();\n    endpoints;\n    issuers;\n    clientAuthentication;\n    // TODO: refactor tests to make this private\n    _clientId;\n    // TODO: refactor tests to make this private\n    _clientSecret;\n    refreshHandler;\n    /**\n     * An OAuth2 Client for Google APIs.\n     *\n     * @param options The OAuth2 Client Options. Passing an `clientId` directly is **@DEPRECATED**.\n     * @param clientSecret **@DEPRECATED**. Provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead.\n     * @param redirectUri **@DEPRECATED**. Provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead.\n     */\n    constructor(options = {}, \n    /**\n     * @deprecated - provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead\n     */\n    clientSecret, \n    /**\n     * @deprecated - provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead\n     */\n    redirectUri) {\n        super(typeof options === 'object' ? options : {});\n        if (typeof options !== 'object') {\n            options = {\n                clientId: options,\n                clientSecret,\n                redirectUri,\n            };\n        }\n        this._clientId = options.clientId || options.client_id;\n        this._clientSecret = options.clientSecret || options.client_secret;\n        this.redirectUri = options.redirectUri || options.redirect_uris?.[0];\n        this.endpoints = {\n            tokenInfoUrl: 'https://oauth2.googleapis.com/tokeninfo',\n            oauth2AuthBaseUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n            oauth2TokenUrl: 'https://oauth2.googleapis.com/token',\n            oauth2RevokeUrl: 'https://oauth2.googleapis.com/revoke',\n            oauth2FederatedSignonPemCertsUrl: 'https://www.googleapis.com/oauth2/v1/certs',\n            oauth2FederatedSignonJwkCertsUrl: 'https://www.googleapis.com/oauth2/v3/certs',\n            oauth2IapPublicKeyUrl: 'https://www.gstatic.com/iap/verify/public_key',\n            ...options.endpoints,\n        };\n        this.clientAuthentication =\n            options.clientAuthentication || ClientAuthentication.ClientSecretPost;\n        this.issuers = options.issuers || [\n            'accounts.google.com',\n            'https://accounts.google.com',\n            this.universeDomain,\n        ];\n    }\n    /**\n     * @deprecated use instance's {@link OAuth2Client.endpoints}\n     */\n    static GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n    /**\n     * Clock skew - five minutes in seconds\n     */\n    static CLOCK_SKEW_SECS_ = 300;\n    /**\n     * The default max Token Lifetime is one day in seconds\n     */\n    static DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n    generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n        }\n        opts.response_type = opts.response_type || 'code';\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (Array.isArray(opts.scope)) {\n            opts.scope = opts.scope.join(' ');\n        }\n        const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();\n        return (rootUrl +\n            '?' +\n            querystring.stringify(opts));\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n     */\n    async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = (0, crypto_1.createCrypto)();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString\n            .replace(/\\+/g, '~')\n            .replace(/=/g, '_')\n            .replace(/\\//g, '-');\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge\n            .split('=')[0]\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_');\n        return { codeVerifier, codeChallenge };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === 'string' ? { code: codeOrOptions } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n        }\n        else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = this.endpoints.oauth2TokenUrl.toString();\n        const headers = new Headers();\n        const values = {\n            client_id: options.client_id || this._clientId,\n            code_verifier: options.codeVerifier,\n            code: options.code,\n            grant_type: 'authorization_code',\n            redirect_uri: options.redirect_uri || this.redirectUri,\n        };\n        if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {\n            const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);\n            headers.set('authorization', `Basic ${basic.toString('base64')}`);\n        }\n        if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) {\n            values.client_secret = this._clientSecret;\n        }\n        const opts = {\n            ...OAuth2Client.RETRY_CONFIG,\n            method: 'POST',\n            url,\n            data: new URLSearchParams((0, util_1.removeUndefinedValuesInObject)(values)),\n            headers,\n        };\n        authclient_1.AuthClient.setMethodName(opts, 'getTokenAsync');\n        const res = await this.transporter.request(opts);\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n    async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then(r => {\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, e => {\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        if (!refreshToken) {\n            throw new Error('No refresh token is set.');\n        }\n        const url = this.endpoints.oauth2TokenUrl.toString();\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: 'refresh_token',\n        };\n        let res;\n        try {\n            const opts = {\n                ...OAuth2Client.RETRY_CONFIG,\n                method: 'POST',\n                url,\n                data: new URLSearchParams((0, util_1.removeUndefinedValuesInObject)(data)),\n            };\n            authclient_1.AuthClient.setMethodName(opts, 'refreshTokenNoCache');\n            // request for new token\n            res = await this.transporter.request(opts);\n        }\n        catch (e) {\n            if (e instanceof gaxios_1.GaxiosError &&\n                e.message === 'invalid_grant' &&\n                e.response?.data &&\n                /ReAuth/i.test(e.response.data.error_description)) {\n                e.message = JSON.stringify(e.response.data);\n            }\n            throw e;\n        }\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n        }\n        else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return { credentials: this.credentials, res: r.res };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n        }\n        else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                if (this.refreshHandler) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken?.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                        return { token: this.credentials.access_token };\n                    }\n                }\n                else {\n                    throw new Error('No refresh token or refresh handler callback is set.');\n                }\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                throw new Error('Could not refresh access token.');\n            }\n            return { token: r.credentials.access_token, res: r.res };\n        }\n        else {\n            return { token: this.credentials.access_token };\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(url) {\n        url;\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token &&\n            !thisCreds.refresh_token &&\n            !this.apiKey &&\n            !this.refreshHandler) {\n            throw new Error('No access, refresh token, API key or refresh handler callback is set.');\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || 'Bearer';\n            const headers = new Headers({\n                authorization: thisCreds.token_type + ' ' + thisCreds.access_token,\n            });\n            return { headers: this.addSharedMetadataHeaders(headers) };\n        }\n        // If refreshHandler exists, call processAndValidateRefreshHandler().\n        if (this.refreshHandler) {\n            const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n            if (refreshedAccessToken?.access_token) {\n                this.setCredentials(refreshedAccessToken);\n                const headers = new Headers({\n                    authorization: 'Bearer ' + this.credentials.access_token,\n                });\n                return { headers: this.addSharedMetadataHeaders(headers) };\n            }\n        }\n        if (this.apiKey) {\n            return { headers: new Headers({ 'X-Goog-Api-Key': this.apiKey }) };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        }\n        catch (err) {\n            const e = err;\n            if (e.response &&\n                (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || 'Bearer';\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = new Headers({\n            authorization: credentials.token_type + ' ' + tokens.access_token,\n        });\n        return { headers: this.addSharedMetadataHeaders(headers), res: r.res };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     *\n     * @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}\n     */\n    static getRevokeTokenUrl(token) {\n        return new OAuth2Client().getRevokeTokenURL(token).toString();\n    }\n    /**\n     * Generates a URL to revoke the given token.\n     *\n     * @param token The existing token to be revoked.\n     */\n    getRevokeTokenURL(token) {\n        const url = new URL(this.endpoints.oauth2RevokeUrl);\n        url.searchParams.append('token', token);\n        return url;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            ...OAuth2Client.RETRY_CONFIG,\n            url: this.getRevokeTokenURL(token).toString(),\n            method: 'POST',\n        };\n        authclient_1.AuthClient.setMethodName(opts, 'revokeToken');\n        if (callback) {\n            this.transporter\n                .request(opts)\n                .then(r => callback(null, r), callback);\n        }\n        else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n        }\n        else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        }\n        else {\n            throw new Error('No access token to revoke.');\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, reAuthRetried = false) {\n        try {\n            const r = await this.getRequestMetadataAsync();\n            opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);\n            this.addUserProjectAndAuthHeaders(opts.headers, r.headers);\n            if (this.apiKey) {\n                opts.headers.set('X-Goog-Api-Key', this.apiKey);\n            }\n            return await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                // Or the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - No refresh_token was available\n                // - An access_token and a refreshHandler callback were available, but\n                //   either no expiry_date was available or the forceRefreshOnFailure\n                //   flag is set. The access_token fails on the first try because it's\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\n                //   to mitigate time-related errors.\n                const mayRequireRefresh = this.credentials &&\n                    this.credentials.access_token &&\n                    this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const mayRequireRefreshWithNoRefreshToken = this.credentials &&\n                    this.credentials.access_token &&\n                    !this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure) &&\n                    this.refreshHandler;\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!reAuthRetried &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                }\n                else if (!reAuthRetried &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    mayRequireRefreshWithNoRefreshToken) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken?.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                    }\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== 'function') {\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error('The verifyIdToken method requires an ID Token');\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n    async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            ...OAuth2Client.RETRY_CONFIG,\n            method: 'POST',\n            headers: {\n                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8',\n                authorization: `Bearer ${accessToken}`,\n            },\n            url: this.endpoints.tokenInfoUrl.toString(),\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(' '),\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n        }\n        else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = (0, crypto_1.hasBrowserCrypto)()\n            ? CertificateFormat.JWK\n            : CertificateFormat.PEM;\n        if (this.certificateExpiry &&\n            nowTime < this.certificateExpiry.getTime() &&\n            this.certificateCacheFormat === format) {\n            return { certs: this.certificateCache, format };\n        }\n        let res;\n        let url;\n        switch (format) {\n            case CertificateFormat.PEM:\n                url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();\n                break;\n            case CertificateFormat.JWK:\n                url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            const opts = {\n                ...OAuth2Client.RETRY_CONFIG,\n                url,\n            };\n            authclient_1.AuthClient.setMethodName(opts, 'getFederatedSignonCertsAsync');\n            res = await this.transporter.request(opts);\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        const cacheControl = res?.headers.get('cache-control');\n        let cacheAge = -1;\n        if (cacheControl) {\n            const maxAge = /max-age=(?<maxAge>[0-9]+)/.exec(cacheControl)?.groups\n                ?.maxAge;\n            if (maxAge) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(maxAge) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch (format) {\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys) {\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry =\n            cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return { certs: certificates, format, res };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n        }\n        else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        let res;\n        const url = this.endpoints.oauth2IapPublicKeyUrl.toString();\n        try {\n            const opts = {\n                ...OAuth2Client.RETRY_CONFIG,\n                url,\n            };\n            authclient_1.AuthClient.setMethodName(opts, 'getIapPublicKeysAsync');\n            res = await this.transporter.request(opts);\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        return { pubkeys: res.data, res };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = (0, crypto_1.createCrypto)();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split('.');\n        if (segments.length !== 3) {\n            throw new Error('Wrong number of segments in token: ' + jwt);\n        }\n        const signed = segments[0] + '.' + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            }\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token payload '${segments[0]}`;\n            }\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === 'ES256') {\n            signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error('Invalid token signature: ' + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error('No issue time in token: ' + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat))\n            throw new Error('iat field using invalid format');\n        const exp = Number(payload.exp);\n        if (isNaN(exp))\n            throw new Error('exp field using invalid format');\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error('Token used too early, ' +\n                now +\n                ' < ' +\n                earliest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error('Token used too late, ' +\n                now +\n                ' > ' +\n                latest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error('Invalid issuer, expected one of [' +\n                issuers +\n                '], but got ' +\n                payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            }\n            else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns a promise that resolves with AccessTokenResponse type if\n     * refreshHandler is defined.\n     * If not, nothing is returned.\n     */\n    async processAndValidateRefreshHandler() {\n        if (this.refreshHandler) {\n            const accessTokenResponse = await this.refreshHandler();\n            if (!accessTokenResponse.access_token) {\n                throw new Error('No access token is returned by the refreshHandler callback.');\n            }\n            return accessTokenResponse;\n        }\n        return;\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n    isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate\n            ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\n//# sourceMappingURL=oauth2client.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}