{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\nimport { handleApiError, retryRequest } from '../../utils/errorHandler';\n\n// Async thunks\nexport const fetchCategories = createAsyncThunk('categories/fetchCategories', async (params = {}, {\n  rejectWithValue,\n  getState\n}) => {\n  try {\n    // Check if we already have categories and this is not a forced refresh\n    const state = getState();\n    if (state.categories.categories.length > 0 && !params.forceRefresh) {\n      return state.categories;\n    }\n    const requestFn = async () => {\n      const response = await axios.get('/api/categories', {\n        params\n      });\n      return response.data.data;\n    };\n\n    // Use retry logic for rate limiting\n    const data = await retryRequest(requestFn, 3, 1000);\n    return data;\n  } catch (error) {\n    var _error$response;\n    const errorInfo = handleApiError(error, error.response);\n\n    // If it's a 429 error, include retry information\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429) {\n      return rejectWithValue({\n        message: errorInfo.message,\n        isRateLimited: true,\n        retryAfter: errorInfo.retryAfter,\n        status: 429\n      });\n    }\n    return rejectWithValue(errorInfo.message || 'Failed to fetch categories');\n  }\n});\nexport const fetchCategory = createAsyncThunk('categories/fetchCategory', async (categoryId, {\n  rejectWithValue\n}) => {\n  try {\n    const requestFn = async () => {\n      const response = await axios.get(`/api/categories/${categoryId}`);\n      return response.data.data;\n    };\n\n    // Use retry logic for rate limiting\n    const data = await retryRequest(requestFn, 3, 1000);\n    return data;\n  } catch (error) {\n    const errorInfo = handleApiError(error, error.response);\n    return rejectWithValue(errorInfo.message || 'Failed to fetch category');\n  }\n});\nconst initialState = {\n  categories: [],\n  currentCategory: null,\n  pagination: {\n    currentPage: 1,\n    totalPages: 1,\n    totalItems: 0,\n    itemsPerPage: 20,\n    hasNextPage: false,\n    hasPrevPage: false\n  },\n  loading: false,\n  error: null,\n  isRateLimited: false,\n  retryAfter: null,\n  lastFetched: null\n};\nconst categorySlice = createSlice({\n  name: 'categories',\n  initialState,\n  reducers: {\n    clearError: state => {\n      state.error = null;\n    },\n    clearCurrentCategory: state => {\n      state.currentCategory = null;\n    },\n    setRateLimited: (state, action) => {\n      state.isRateLimited = action.payload.isRateLimited;\n      state.retryAfter = action.payload.retryAfter;\n    },\n    clearRateLimit: state => {\n      state.isRateLimited = false;\n      state.retryAfter = null;\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Fetch categories\n    .addCase(fetchCategories.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchCategories.fulfilled, (state, action) => {\n      state.loading = false;\n      state.categories = action.payload.categories;\n      state.pagination = action.payload.pagination;\n      state.error = null;\n      state.isRateLimited = false;\n      state.retryAfter = null;\n      state.lastFetched = Date.now();\n    }).addCase(fetchCategories.rejected, (state, action) => {\n      state.loading = false;\n\n      // Handle rate limit error with retry information\n      if (action.payload && typeof action.payload === 'object' && action.payload.isRateLimited) {\n        state.error = action.payload.message;\n        state.isRateLimited = true;\n        state.retryAfter = action.payload.retryAfter || 60;\n      } else {\n        state.error = action.payload;\n        state.isRateLimited = false;\n        state.retryAfter = null;\n      }\n    })\n    // Fetch single category\n    .addCase(fetchCategory.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchCategory.fulfilled, (state, action) => {\n      state.loading = false;\n      state.currentCategory = action.payload.category;\n      state.error = null;\n    }).addCase(fetchCategory.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    });\n  }\n});\nexport const {\n  clearError,\n  clearCurrentCategory,\n  setRateLimited,\n  clearRateLimit\n} = categorySlice.actions;\nexport default categorySlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","axios","handleApiError","retryRequest","fetchCategories","params","rejectWithValue","getState","state","categories","length","forceRefresh","requestFn","response","get","data","error","_error$response","errorInfo","status","message","isRateLimited","retryAfter","fetchCategory","categoryId","initialState","currentCategory","pagination","currentPage","totalPages","totalItems","itemsPerPage","hasNextPage","hasPrevPage","loading","lastFetched","categorySlice","name","reducers","clearError","clearCurrentCategory","setRateLimited","action","payload","clearRateLimit","extraReducers","builder","addCase","pending","fulfilled","Date","now","rejected","category","actions","reducer"],"sources":["E:/blowpack/frountend/src/store/slices/categorySlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\nimport { handleApiError, retryRequest } from '../../utils/errorHandler';\n\n// Async thunks\nexport const fetchCategories = createAsyncThunk(\n  'categories/fetchCategories',\n  async (params = {}, { rejectWithValue, getState }) => {\n    try {\n      // Check if we already have categories and this is not a forced refresh\n      const state = getState();\n      if (state.categories.categories.length > 0 && !params.forceRefresh) {\n        return state.categories;\n      }\n\n      const requestFn = async () => {\n        const response = await axios.get('/api/categories', { params });\n        return response.data.data;\n      };\n\n      // Use retry logic for rate limiting\n      const data = await retryRequest(requestFn, 3, 1000);\n      return data;\n    } catch (error) {\n      const errorInfo = handleApiError(error, error.response);\n      \n      // If it's a 429 error, include retry information\n      if (error.response?.status === 429) {\n        return rejectWithValue({\n          message: errorInfo.message,\n          isRateLimited: true,\n          retryAfter: errorInfo.retryAfter,\n          status: 429\n        });\n      }\n      \n      return rejectWithValue(errorInfo.message || 'Failed to fetch categories');\n    }\n  }\n);\n\nexport const fetchCategory = createAsyncThunk(\n  'categories/fetchCategory',\n  async (categoryId, { rejectWithValue }) => {\n    try {\n      const requestFn = async () => {\n        const response = await axios.get(`/api/categories/${categoryId}`);\n        return response.data.data;\n      };\n\n      // Use retry logic for rate limiting\n      const data = await retryRequest(requestFn, 3, 1000);\n      return data;\n    } catch (error) {\n      const errorInfo = handleApiError(error, error.response);\n      return rejectWithValue(errorInfo.message || 'Failed to fetch category');\n    }\n  }\n);\n\nconst initialState = {\n  categories: [],\n  currentCategory: null,\n  pagination: {\n    currentPage: 1,\n    totalPages: 1,\n    totalItems: 0,\n    itemsPerPage: 20,\n    hasNextPage: false,\n    hasPrevPage: false,\n  },\n  loading: false,\n  error: null,\n  isRateLimited: false,\n  retryAfter: null,\n  lastFetched: null,\n};\n\nconst categorySlice = createSlice({\n  name: 'categories',\n  initialState,\n  reducers: {\n    clearError: (state) => {\n      state.error = null;\n    },\n    clearCurrentCategory: (state) => {\n      state.currentCategory = null;\n    },\n    setRateLimited: (state, action) => {\n      state.isRateLimited = action.payload.isRateLimited;\n      state.retryAfter = action.payload.retryAfter;\n    },\n    clearRateLimit: (state) => {\n      state.isRateLimited = false;\n      state.retryAfter = null;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      // Fetch categories\n      .addCase(fetchCategories.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchCategories.fulfilled, (state, action) => {\n        state.loading = false;\n        state.categories = action.payload.categories;\n        state.pagination = action.payload.pagination;\n        state.error = null;\n        state.isRateLimited = false;\n        state.retryAfter = null;\n        state.lastFetched = Date.now();\n      })\n      .addCase(fetchCategories.rejected, (state, action) => {\n        state.loading = false;\n        \n        // Handle rate limit error with retry information\n        if (action.payload && typeof action.payload === 'object' && action.payload.isRateLimited) {\n          state.error = action.payload.message;\n          state.isRateLimited = true;\n          state.retryAfter = action.payload.retryAfter || 60;\n        } else {\n          state.error = action.payload;\n          state.isRateLimited = false;\n          state.retryAfter = null;\n        }\n      })\n      // Fetch single category\n      .addCase(fetchCategory.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchCategory.fulfilled, (state, action) => {\n        state.loading = false;\n        state.currentCategory = action.payload.category;\n        state.error = null;\n      })\n      .addCase(fetchCategory.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload;\n      });\n  },\n});\n\nexport const { clearError, clearCurrentCategory, setRateLimited, clearRateLimit } = categorySlice.actions;\nexport default categorySlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}