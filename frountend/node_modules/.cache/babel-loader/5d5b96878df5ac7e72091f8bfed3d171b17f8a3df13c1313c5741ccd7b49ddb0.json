{"ast":null,"code":"\"use strict\";\n\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst gaxios_1 = require(\"gaxios\");\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\nconst util_1 = require(\"../util\");\nconst shared_cjs_1 = require(\"../shared.cjs\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** Default impersonated token lifespan in seconds.*/\nconst DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/**\n * Cloud resource manager URL used to retrieve project information.\n *\n * @deprecated use {@link BaseExternalAccountClient.cloudResourceManagerURL} instead\n **/\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam\\\\.googleapis\\\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\nconst DEFAULT_TOKEN_URL = 'https://sts.{universeDomain}/v1/token';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n  /**\n   * OAuth scopes for the GCP access token to use. When not provided,\n   * the default https://www.googleapis.com/auth/cloud-platform is\n   * used.\n   */\n  scopes;\n  projectNumber;\n  audience;\n  subjectTokenType;\n  stsCredential;\n  clientAuth;\n  credentialSourceType;\n  cachedAccessToken;\n  serviceAccountImpersonationUrl;\n  serviceAccountImpersonationLifetime;\n  workforcePoolUserProject;\n  configLifetimeRequested;\n  tokenUrl;\n  /**\n   * @example\n   * ```ts\n   * new URL('https://cloudresourcemanager.googleapis.com/v1/projects/');\n   * ```\n   */\n  cloudResourceManagerURL;\n  supplierContext;\n  /**\n   * A pending access token request. Used for concurrent calls.\n   */\n  #pendingAccessToken = null;\n  /**\n   * Instantiate a BaseExternalAccountClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file. The camelCased options\n   *   are aliases for the snake_cased options.\n   */\n  constructor(options) {\n    super(options);\n    const opts = (0, util_1.originalOrCamelOptions)(options);\n    const type = opts.get('type');\n    if (type && type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n      throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` + `received \"${options.type}\"`);\n    }\n    const clientId = opts.get('client_id');\n    const clientSecret = opts.get('client_secret');\n    this.tokenUrl = opts.get('token_url') ?? DEFAULT_TOKEN_URL.replace('{universeDomain}', this.universeDomain);\n    const subjectTokenType = opts.get('subject_token_type');\n    const workforcePoolUserProject = opts.get('workforce_pool_user_project');\n    const serviceAccountImpersonationUrl = opts.get('service_account_impersonation_url');\n    const serviceAccountImpersonation = opts.get('service_account_impersonation');\n    const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get('token_lifetime_seconds');\n    this.cloudResourceManagerURL = new URL(opts.get('cloud_resource_manager_url') || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);\n    if (clientId) {\n      this.clientAuth = {\n        confidentialClientType: 'basic',\n        clientId,\n        clientSecret\n      };\n    }\n    this.stsCredential = new sts.StsCredentials({\n      tokenExchangeEndpoint: this.tokenUrl,\n      clientAuthentication: this.clientAuth\n    });\n    this.scopes = opts.get('scopes') || [DEFAULT_OAUTH_SCOPE];\n    this.cachedAccessToken = null;\n    this.audience = opts.get('audience');\n    this.subjectTokenType = subjectTokenType;\n    this.workforcePoolUserProject = workforcePoolUserProject;\n    const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n    if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {\n      throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' + 'credentials.');\n    }\n    this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;\n    this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;\n    if (this.serviceAccountImpersonationLifetime) {\n      this.configLifetimeRequested = true;\n    } else {\n      this.configLifetimeRequested = false;\n      this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;\n    }\n    this.projectNumber = this.getProjectNumber(this.audience);\n    this.supplierContext = {\n      audience: this.audience,\n      subjectTokenType: this.subjectTokenType,\n      transporter: this.transporter\n    };\n  }\n  /** The service account email to be impersonated, if available. */\n  getServiceAccountEmail() {\n    if (this.serviceAccountImpersonationUrl) {\n      if (this.serviceAccountImpersonationUrl.length > 256) {\n        /**\n         * Prevents DOS attacks.\n         * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/84}\n         **/\n        throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);\n      }\n      // Parse email from URL. The formal looks as follows:\n      // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n      const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n      const result = re.exec(this.serviceAccountImpersonationUrl);\n      return result?.groups?.email || null;\n    }\n    return null;\n  }\n  /**\n   * Provides a mechanism to inject GCP access tokens directly.\n   * When the provided credential expires, a new credential, using the\n   * external account options, is retrieved.\n   * @param credentials The Credentials object to set on the current client.\n   */\n  setCredentials(credentials) {\n    super.setCredentials(credentials);\n    this.cachedAccessToken = credentials;\n  }\n  /**\n   * @return A promise that resolves with the current GCP access token\n   *   response. If the current credential is expired, a new one is retrieved.\n   */\n  async getAccessToken() {\n    // If cached access token is unavailable or expired, force refresh.\n    if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n      await this.refreshAccessTokenAsync();\n    }\n    // Return GCP access token in GetAccessTokenResponse format.\n    return {\n      token: this.cachedAccessToken.access_token,\n      res: this.cachedAccessToken.res\n    };\n  }\n  /**\n   * The main authentication interface. It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * The result has the form:\n   * { authorization: 'Bearer <access_token_value>' }\n   */\n  async getRequestHeaders() {\n    const accessTokenResponse = await this.getAccessToken();\n    const headers = new Headers({\n      authorization: `Bearer ${accessTokenResponse.token}`\n    });\n    return this.addSharedMetadataHeaders(headers);\n  }\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * @return A promise that resolves with the project ID corresponding to the\n   *   current workload identity pool or current workforce pool if\n   *   determinable. For workforce pool credential, it returns the project ID\n   *   corresponding to the workforcePoolUserProject.\n   *   This is introduced to match the current pattern of using the Auth\n   *   library:\n   *   const projectId = await auth.getProjectId();\n   *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n   *   const res = await client.request({ url });\n   *   The resource may not have permission\n   *   (resourcemanager.projects.get) to call this API or the required\n   *   scopes may not be selected:\n   *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n   */\n  async getProjectId() {\n    const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n    if (this.projectId) {\n      // Return previously determined project ID.\n      return this.projectId;\n    } else if (projectNumber) {\n      // Preferable not to use request() to avoid retrial policies.\n      const headers = await this.getRequestHeaders();\n      const opts = {\n        ...BaseExternalAccountClient.RETRY_CONFIG,\n        headers,\n        url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`\n      };\n      authclient_1.AuthClient.setMethodName(opts, 'getProjectId');\n      const response = await this.transporter.request(opts);\n      this.projectId = response.data.projectId;\n      return this.projectId;\n    }\n    return null;\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.\n   * @return A promise that resolves with the successful response.\n   */\n  async requestAsync(opts, reAuthRetried = false) {\n    let response;\n    try {\n      const requestHeaders = await this.getRequestHeaders();\n      opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);\n      this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);\n      response = await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - forceRefreshOnFailure is true\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n          await this.refreshAccessTokenAsync();\n          return await this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return response;\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * External credentials are exchanged for GCP access tokens via the token\n   * exchange endpoint and other settings provided in the client options\n   * object.\n   * If the service_account_impersonation_url is provided, an additional\n   * step to exchange the external account GCP access token for a service\n   * account impersonated token is performed.\n   * @return A promise that resolves with the fresh GCP access tokens.\n   */\n  async refreshAccessTokenAsync() {\n    // Use an existing access token request, or cache a new one\n    this.#pendingAccessToken = this.#pendingAccessToken || this.#internalRefreshAccessTokenAsync();\n    try {\n      return await this.#pendingAccessToken;\n    } finally {\n      // clear pending access token for future requests\n      this.#pendingAccessToken = null;\n    }\n  }\n  async #internalRefreshAccessTokenAsync() {\n    // Retrieve the external credential.\n    const subjectToken = await this.retrieveSubjectToken();\n    // Construct the STS credentials options.\n    const stsCredentialsOptions = {\n      grantType: STS_GRANT_TYPE,\n      audience: this.audience,\n      requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n      subjectToken,\n      subjectTokenType: this.subjectTokenType,\n      // generateAccessToken requires the provided access token to have\n      // scopes:\n      // https://www.googleapis.com/auth/iam or\n      // https://www.googleapis.com/auth/cloud-platform\n      // The new service account access token scopes will match the user\n      // provided ones.\n      scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()\n    };\n    // Exchange the external credentials for a GCP access token.\n    // Client auth is prioritized over passing the workforcePoolUserProject\n    // parameter for STS token exchange.\n    const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? {\n      userProject: this.workforcePoolUserProject\n    } : undefined;\n    const additionalHeaders = new Headers({\n      'x-goog-api-client': this.getMetricsHeaderValue()\n    });\n    const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);\n    if (this.serviceAccountImpersonationUrl) {\n      this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n    } else if (stsResponse.expires_in) {\n      // Save response in cached access token.\n      this.cachedAccessToken = {\n        access_token: stsResponse.access_token,\n        expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n        res: stsResponse.res\n      };\n    } else {\n      // Save response in cached access token.\n      this.cachedAccessToken = {\n        access_token: stsResponse.access_token,\n        res: stsResponse.res\n      };\n    }\n    // Save credentials.\n    this.credentials = {};\n    Object.assign(this.credentials, this.cachedAccessToken);\n    delete this.credentials.res;\n    // Trigger tokens event to notify external listeners.\n    this.emit('tokens', {\n      refresh_token: null,\n      expiry_date: this.cachedAccessToken.expiry_date,\n      access_token: this.cachedAccessToken.access_token,\n      token_type: 'Bearer',\n      id_token: null\n    });\n    // Return the cached access token.\n    return this.cachedAccessToken;\n  }\n  /**\n   * Returns the workload identity pool project number if it is determinable\n   * from the audience resource name.\n   * @param audience The STS audience used to determine the project number.\n   * @return The project number associated with the workload identity pool, if\n   *   this can be determined from the STS audience field. Otherwise, null is\n   *   returned.\n   */\n  getProjectNumber(audience) {\n    // STS audience pattern:\n    // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n    const match = audience.match(/\\/projects\\/([^/]+)/);\n    if (!match) {\n      return null;\n    }\n    return match[1];\n  }\n  /**\n   * Exchanges an external account GCP access token for a service\n   * account impersonated access token using iamcredentials\n   * GenerateAccessToken API.\n   * @param token The access token to exchange for a service account access\n   *   token.\n   * @return A promise that resolves with the service account impersonated\n   *   credentials response.\n   */\n  async getImpersonatedAccessToken(token) {\n    const opts = {\n      ...BaseExternalAccountClient.RETRY_CONFIG,\n      url: this.serviceAccountImpersonationUrl,\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n        authorization: `Bearer ${token}`\n      },\n      data: {\n        scope: this.getScopesArray(),\n        lifetime: this.serviceAccountImpersonationLifetime + 's'\n      }\n    };\n    authclient_1.AuthClient.setMethodName(opts, 'getImpersonatedAccessToken');\n    const response = await this.transporter.request(opts);\n    const successResponse = response.data;\n    return {\n      access_token: successResponse.accessToken,\n      // Convert from ISO format to timestamp.\n      expiry_date: new Date(successResponse.expireTime).getTime(),\n      res: response\n    };\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param accessToken The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n  isExpired(accessToken) {\n    const now = new Date().getTime();\n    return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n  /**\n   * @return The list of scopes for the requested GCP access token.\n   */\n  getScopesArray() {\n    // Since scopes can be provided as string or array, the type should\n    // be normalized.\n    if (typeof this.scopes === 'string') {\n      return [this.scopes];\n    }\n    return this.scopes || [DEFAULT_OAUTH_SCOPE];\n  }\n  getMetricsHeaderValue() {\n    const nodeVersion = process.version.replace(/^v/, '');\n    const saImpersonation = this.serviceAccountImpersonationUrl !== undefined;\n    const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : 'unknown';\n    return `gl-node/${nodeVersion} auth/${shared_cjs_1.pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;\n  }\n  getTokenUrl() {\n    return this.tokenUrl;\n  }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","BaseExternalAccountClient","CLOUD_RESOURCE_MANAGER","EXTERNAL_ACCOUNT_TYPE","EXPIRATION_TIME_OFFSET","gaxios_1","require","stream","authclient_1","sts","util_1","shared_cjs_1","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","DEFAULT_OAUTH_SCOPE","DEFAULT_TOKEN_LIFESPAN","WORKFORCE_AUDIENCE_PATTERN","DEFAULT_TOKEN_URL","AuthClient","scopes","projectNumber","audience","subjectTokenType","stsCredential","clientAuth","credentialSourceType","cachedAccessToken","serviceAccountImpersonationUrl","serviceAccountImpersonationLifetime","workforcePoolUserProject","configLifetimeRequested","tokenUrl","cloudResourceManagerURL","supplierContext","pendingAccessToken","constructor","options","opts","originalOrCamelOptions","type","get","Error","clientId","clientSecret","replace","universeDomain","serviceAccountImpersonation","URL","confidentialClientType","StsCredentials","tokenExchangeEndpoint","clientAuthentication","workforceAudiencePattern","RegExp","match","getProjectNumber","transporter","getServiceAccountEmail","length","RangeError","re","result","exec","groups","email","setCredentials","credentials","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","res","getRequestHeaders","accessTokenResponse","headers","Headers","authorization","addSharedMetadataHeaders","request","callback","requestAsync","then","r","e","response","getProjectId","projectId","RETRY_CONFIG","url","toString","setMethodName","data","reAuthRetried","requestHeaders","Gaxios","mergeHeaders","addUserProjectAndAuthHeaders","statusCode","status","isReadableStream","config","Readable","isAuthErr","forceRefreshOnFailure","internalRefreshAccessTokenAsync","#internalRefreshAccessTokenAsync","subjectToken","retrieveSubjectToken","stsCredentialsOptions","grantType","requestedTokenType","scope","getScopesArray","additionalOptions","userProject","undefined","additionalHeaders","getMetricsHeaderValue","stsResponse","exchangeToken","getImpersonatedAccessToken","expires_in","expiry_date","Date","getTime","assign","emit","refresh_token","token_type","id_token","method","lifetime","successResponse","accessToken","expireTime","now","eagerRefreshThresholdMillis","nodeVersion","process","version","saImpersonation","pkg","getTokenUrl"],"sources":["E:/blowpack/frountend/node_modules/google-auth-library/build/src/auth/baseexternalclient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst gaxios_1 = require(\"gaxios\");\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\nconst util_1 = require(\"../util\");\nconst shared_cjs_1 = require(\"../shared.cjs\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** Default impersonated token lifespan in seconds.*/\nconst DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/**\n * Cloud resource manager URL used to retrieve project information.\n *\n * @deprecated use {@link BaseExternalAccountClient.cloudResourceManagerURL} instead\n **/\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam\\\\.googleapis\\\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\nconst DEFAULT_TOKEN_URL = 'https://sts.{universeDomain}/v1/token';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * OAuth scopes for the GCP access token to use. When not provided,\n     * the default https://www.googleapis.com/auth/cloud-platform is\n     * used.\n     */\n    scopes;\n    projectNumber;\n    audience;\n    subjectTokenType;\n    stsCredential;\n    clientAuth;\n    credentialSourceType;\n    cachedAccessToken;\n    serviceAccountImpersonationUrl;\n    serviceAccountImpersonationLifetime;\n    workforcePoolUserProject;\n    configLifetimeRequested;\n    tokenUrl;\n    /**\n     * @example\n     * ```ts\n     * new URL('https://cloudresourcemanager.googleapis.com/v1/projects/');\n     * ```\n     */\n    cloudResourceManagerURL;\n    supplierContext;\n    /**\n     * A pending access token request. Used for concurrent calls.\n     */\n    #pendingAccessToken = null;\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file. The camelCased options\n     *   are aliases for the snake_cased options.\n     */\n    constructor(options) {\n        super(options);\n        const opts = (0, util_1.originalOrCamelOptions)(options);\n        const type = opts.get('type');\n        if (type && type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` +\n                `received \"${options.type}\"`);\n        }\n        const clientId = opts.get('client_id');\n        const clientSecret = opts.get('client_secret');\n        this.tokenUrl =\n            opts.get('token_url') ??\n                DEFAULT_TOKEN_URL.replace('{universeDomain}', this.universeDomain);\n        const subjectTokenType = opts.get('subject_token_type');\n        const workforcePoolUserProject = opts.get('workforce_pool_user_project');\n        const serviceAccountImpersonationUrl = opts.get('service_account_impersonation_url');\n        const serviceAccountImpersonation = opts.get('service_account_impersonation');\n        const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get('token_lifetime_seconds');\n        this.cloudResourceManagerURL = new URL(opts.get('cloud_resource_manager_url') ||\n            `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);\n        if (clientId) {\n            this.clientAuth = {\n                confidentialClientType: 'basic',\n                clientId,\n                clientSecret,\n            };\n        }\n        this.stsCredential = new sts.StsCredentials({\n            tokenExchangeEndpoint: this.tokenUrl,\n            clientAuthentication: this.clientAuth,\n        });\n        this.scopes = opts.get('scopes') || [DEFAULT_OAUTH_SCOPE];\n        this.cachedAccessToken = null;\n        this.audience = opts.get('audience');\n        this.subjectTokenType = subjectTokenType;\n        this.workforcePoolUserProject = workforcePoolUserProject;\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n        if (this.workforcePoolUserProject &&\n            !this.audience.match(workforceAudiencePattern)) {\n            throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' +\n                'credentials.');\n        }\n        this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;\n        this.serviceAccountImpersonationLifetime =\n            serviceAccountImpersonationLifetime;\n        if (this.serviceAccountImpersonationLifetime) {\n            this.configLifetimeRequested = true;\n        }\n        else {\n            this.configLifetimeRequested = false;\n            this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;\n        }\n        this.projectNumber = this.getProjectNumber(this.audience);\n        this.supplierContext = {\n            audience: this.audience,\n            subjectTokenType: this.subjectTokenType,\n            transporter: this.transporter,\n        };\n    }\n    /** The service account email to be impersonated, if available. */\n    getServiceAccountEmail() {\n        if (this.serviceAccountImpersonationUrl) {\n            if (this.serviceAccountImpersonationUrl.length > 256) {\n                /**\n                 * Prevents DOS attacks.\n                 * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/84}\n                 **/\n                throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);\n            }\n            // Parse email from URL. The formal looks as follows:\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n            const result = re.exec(this.serviceAccountImpersonationUrl);\n            return result?.groups?.email || null;\n        }\n        return null;\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = new Headers({\n            authorization: `Bearer ${accessTokenResponse.token}`,\n        });\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool or current workforce pool if\n     *   determinable. For workforce pool credential, it returns the project ID\n     *   corresponding to the workforcePoolUserProject.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */\n    async getProjectId() {\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        }\n        else if (projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const opts = {\n                ...BaseExternalAccountClient.RETRY_CONFIG,\n                headers,\n                url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`,\n            };\n            authclient_1.AuthClient.setMethodName(opts, 'getProjectId');\n            const response = await this.transporter.request(opts);\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, reAuthRetried = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);\n            this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!reAuthRetried &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */\n    async refreshAccessTokenAsync() {\n        // Use an existing access token request, or cache a new one\n        this.#pendingAccessToken =\n            this.#pendingAccessToken || this.#internalRefreshAccessTokenAsync();\n        try {\n            return await this.#pendingAccessToken;\n        }\n        finally {\n            // clear pending access token for future requests\n            this.#pendingAccessToken = null;\n        }\n    }\n    async #internalRefreshAccessTokenAsync() {\n        // Retrieve the external credential.\n        const subjectToken = await this.retrieveSubjectToken();\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            audience: this.audience,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken,\n            subjectTokenType: this.subjectTokenType,\n            // generateAccessToken requires the provided access token to have\n            // scopes:\n            // https://www.googleapis.com/auth/iam or\n            // https://www.googleapis.com/auth/cloud-platform\n            // The new service account access token scopes will match the user\n            // provided ones.\n            scope: this.serviceAccountImpersonationUrl\n                ? [DEFAULT_OAUTH_SCOPE]\n                : this.getScopesArray(),\n        };\n        // Exchange the external credentials for a GCP access token.\n        // Client auth is prioritized over passing the workforcePoolUserProject\n        // parameter for STS token exchange.\n        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject\n            ? { userProject: this.workforcePoolUserProject }\n            : undefined;\n        const additionalHeaders = new Headers({\n            'x-goog-api-client': this.getMetricsHeaderValue(),\n        });\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);\n        if (this.serviceAccountImpersonationUrl) {\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n        }\n        else if (stsResponse.expires_in) {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                res: stsResponse.res,\n            };\n        }\n        else {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                res: stsResponse.res,\n            };\n        }\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedAccessToken.expiry_date,\n            access_token: this.cachedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */\n    getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */\n    async getImpersonatedAccessToken(token) {\n        const opts = {\n            ...BaseExternalAccountClient.RETRY_CONFIG,\n            url: this.serviceAccountImpersonationUrl,\n            method: 'POST',\n            headers: {\n                'content-type': 'application/json',\n                authorization: `Bearer ${token}`,\n            },\n            data: {\n                scope: this.getScopesArray(),\n                lifetime: this.serviceAccountImpersonationLifetime + 's',\n            },\n        };\n        authclient_1.AuthClient.setMethodName(opts, 'getImpersonatedAccessToken');\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response,\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date\n            ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */\n    getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === 'string') {\n            return [this.scopes];\n        }\n        return this.scopes || [DEFAULT_OAUTH_SCOPE];\n    }\n    getMetricsHeaderValue() {\n        const nodeVersion = process.version.replace(/^v/, '');\n        const saImpersonation = this.serviceAccountImpersonationUrl !== undefined;\n        const credentialSourceType = this.credentialSourceType\n            ? this.credentialSourceType\n            : 'unknown';\n        return `gl-node/${nodeVersion} auth/${shared_cjs_1.pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;\n    }\n    getTokenUrl() {\n        return this.tokenUrl;\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\n//# sourceMappingURL=baseexternalclient.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}