{"ast":null,"code":"\"use strict\";\n\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PluggableAuthHandler = exports.ExecutableError = void 0;\nconst executable_response_1 = require(\"./executable-response\");\nconst childProcess = require(\"child_process\");\nconst fs = require(\"fs\");\n/**\n * Error thrown from the executable run by PluggableAuthClient.\n */\nclass ExecutableError extends Error {\n  /**\n   * The exit code returned by the executable.\n   */\n  code;\n  constructor(message, code) {\n    super(`The executable failed with exit code: ${code} and error message: ${message}.`);\n    this.code = code;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\nexports.ExecutableError = ExecutableError;\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\nclass PluggableAuthHandler {\n  commandComponents;\n  timeoutMillis;\n  outputFile;\n  /**\n   * Instantiates a PluggableAuthHandler instance using the provided\n   * PluggableAuthHandlerOptions object.\n   */\n  constructor(options) {\n    if (!options.command) {\n      throw new Error('No command provided.');\n    }\n    this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n    this.timeoutMillis = options.timeoutMillis;\n    if (!this.timeoutMillis) {\n      throw new Error('No timeoutMillis provided.');\n    }\n    this.outputFile = options.outputFile;\n  }\n  /**\n   * Calls user provided executable to get a 3rd party subject token and\n   * returns the response.\n   * @param envMap a Map of additional Environment Variables required for\n   *   the executable.\n   * @return A promise that resolves with the executable response.\n   */\n  retrieveResponseFromExecutable(envMap) {\n    return new Promise((resolve, reject) => {\n      // Spawn process to run executable using added environment variables.\n      const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n        env: {\n          ...process.env,\n          ...Object.fromEntries(envMap)\n        }\n      });\n      let output = '';\n      // Append stdout to output as executable runs.\n      child.stdout.on('data', data => {\n        output += data;\n      });\n      // Append stderr as executable runs.\n      child.stderr.on('data', err => {\n        output += err;\n      });\n      // Set up a timeout to end the child process and throw an error.\n      const timeout = setTimeout(() => {\n        // Kill child process and remove listeners so 'close' event doesn't get\n        // read after child process is killed.\n        child.removeAllListeners();\n        child.kill();\n        return reject(new Error('The executable failed to finish within the timeout specified.'));\n      }, this.timeoutMillis);\n      child.on('close', code => {\n        // Cancel timeout if executable closes before timeout is reached.\n        clearTimeout(timeout);\n        if (code === 0) {\n          // If the executable completed successfully, try to return the parsed response.\n          try {\n            const responseJson = JSON.parse(output);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            return resolve(response);\n          } catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n              return reject(error);\n            }\n            return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n          }\n        } else {\n          return reject(new ExecutableError(output, code.toString()));\n        }\n      });\n    });\n  }\n  /**\n   * Checks user provided output file for response from previous run of\n   * executable and return the response if it exists, is formatted correctly, and is not expired.\n   */\n  async retrieveCachedResponse() {\n    if (!this.outputFile || this.outputFile.length === 0) {\n      return undefined;\n    }\n    let filePath;\n    try {\n      filePath = await fs.promises.realpath(this.outputFile);\n    } catch {\n      // If file path cannot be resolved, return undefined.\n      return undefined;\n    }\n    if (!(await fs.promises.lstat(filePath)).isFile()) {\n      // If path does not lead to file, return undefined.\n      return undefined;\n    }\n    const responseString = await fs.promises.readFile(filePath, {\n      encoding: 'utf8'\n    });\n    if (responseString === '') {\n      return undefined;\n    }\n    try {\n      const responseJson = JSON.parse(responseString);\n      const response = new executable_response_1.ExecutableResponse(responseJson);\n      // Check if response is successful and unexpired.\n      if (response.isValid()) {\n        return new executable_response_1.ExecutableResponse(responseJson);\n      }\n      return undefined;\n    } catch (error) {\n      if (error instanceof executable_response_1.ExecutableResponseError) {\n        throw error;\n      }\n      throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n    }\n  }\n  /**\n   * Parses given command string into component array, splitting on spaces unless\n   * spaces are between quotation marks.\n   */\n  static parseCommand(command) {\n    // Split the command into components by splitting on spaces,\n    // unless spaces are contained in quotation marks.\n    const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n    if (!components) {\n      throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n    }\n    // Remove quotation marks from the beginning and end of each component if they are present.\n    for (let i = 0; i < components.length; i++) {\n      if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n        components[i] = components[i].slice(1, -1);\n      }\n    }\n    return components;\n  }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;","map":{"version":3,"names":["Object","defineProperty","exports","value","PluggableAuthHandler","ExecutableError","executable_response_1","require","childProcess","fs","Error","code","constructor","message","setPrototypeOf","new","target","prototype","commandComponents","timeoutMillis","outputFile","options","command","parseCommand","retrieveResponseFromExecutable","envMap","Promise","resolve","reject","child","spawn","slice","env","process","fromEntries","output","stdout","on","data","stderr","err","timeout","setTimeout","removeAllListeners","kill","clearTimeout","responseJson","JSON","parse","response","ExecutableResponse","error","ExecutableResponseError","toString","retrieveCachedResponse","length","undefined","filePath","promises","realpath","lstat","isFile","responseString","readFile","encoding","isValid","components","match","i"],"sources":["E:/blowpack/frountend/node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js"],"sourcesContent":["\"use strict\";\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PluggableAuthHandler = exports.ExecutableError = void 0;\nconst executable_response_1 = require(\"./executable-response\");\nconst childProcess = require(\"child_process\");\nconst fs = require(\"fs\");\n/**\n * Error thrown from the executable run by PluggableAuthClient.\n */\nclass ExecutableError extends Error {\n    /**\n     * The exit code returned by the executable.\n     */\n    code;\n    constructor(message, code) {\n        super(`The executable failed with exit code: ${code} and error message: ${message}.`);\n        this.code = code;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableError = ExecutableError;\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\nclass PluggableAuthHandler {\n    commandComponents;\n    timeoutMillis;\n    outputFile;\n    /**\n     * Instantiates a PluggableAuthHandler instance using the provided\n     * PluggableAuthHandlerOptions object.\n     */\n    constructor(options) {\n        if (!options.command) {\n            throw new Error('No command provided.');\n        }\n        this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n        this.timeoutMillis = options.timeoutMillis;\n        if (!this.timeoutMillis) {\n            throw new Error('No timeoutMillis provided.');\n        }\n        this.outputFile = options.outputFile;\n    }\n    /**\n     * Calls user provided executable to get a 3rd party subject token and\n     * returns the response.\n     * @param envMap a Map of additional Environment Variables required for\n     *   the executable.\n     * @return A promise that resolves with the executable response.\n     */\n    retrieveResponseFromExecutable(envMap) {\n        return new Promise((resolve, reject) => {\n            // Spawn process to run executable using added environment variables.\n            const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n                env: { ...process.env, ...Object.fromEntries(envMap) },\n            });\n            let output = '';\n            // Append stdout to output as executable runs.\n            child.stdout.on('data', (data) => {\n                output += data;\n            });\n            // Append stderr as executable runs.\n            child.stderr.on('data', (err) => {\n                output += err;\n            });\n            // Set up a timeout to end the child process and throw an error.\n            const timeout = setTimeout(() => {\n                // Kill child process and remove listeners so 'close' event doesn't get\n                // read after child process is killed.\n                child.removeAllListeners();\n                child.kill();\n                return reject(new Error('The executable failed to finish within the timeout specified.'));\n            }, this.timeoutMillis);\n            child.on('close', (code) => {\n                // Cancel timeout if executable closes before timeout is reached.\n                clearTimeout(timeout);\n                if (code === 0) {\n                    // If the executable completed successfully, try to return the parsed response.\n                    try {\n                        const responseJson = JSON.parse(output);\n                        const response = new executable_response_1.ExecutableResponse(responseJson);\n                        return resolve(response);\n                    }\n                    catch (error) {\n                        if (error instanceof executable_response_1.ExecutableResponseError) {\n                            return reject(error);\n                        }\n                        return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n                    }\n                }\n                else {\n                    return reject(new ExecutableError(output, code.toString()));\n                }\n            });\n        });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */\n    async retrieveCachedResponse() {\n        if (!this.outputFile || this.outputFile.length === 0) {\n            return undefined;\n        }\n        let filePath;\n        try {\n            filePath = await fs.promises.realpath(this.outputFile);\n        }\n        catch {\n            // If file path cannot be resolved, return undefined.\n            return undefined;\n        }\n        if (!(await fs.promises.lstat(filePath)).isFile()) {\n            // If path does not lead to file, return undefined.\n            return undefined;\n        }\n        const responseString = await fs.promises.readFile(filePath, {\n            encoding: 'utf8',\n        });\n        if (responseString === '') {\n            return undefined;\n        }\n        try {\n            const responseJson = JSON.parse(responseString);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            // Check if response is successful and unexpired.\n            if (response.isValid()) {\n                return new executable_response_1.ExecutableResponse(responseJson);\n            }\n            return undefined;\n        }\n        catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n                throw error;\n            }\n            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n        }\n    }\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */\n    static parseCommand(command) {\n        // Split the command into components by splitting on spaces,\n        // unless spaces are contained in quotation marks.\n        const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n        if (!components) {\n            throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n        }\n        // Remove quotation marks from the beginning and end of each component if they are present.\n        for (let i = 0; i < components.length; i++) {\n            if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n                components[i] = components[i].slice(1, -1);\n            }\n        }\n        return components;\n    }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;\n//# sourceMappingURL=pluggable-auth-handler.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}