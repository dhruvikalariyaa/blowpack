{"ast":null,"code":"\"use strict\";\n\n// Copyright 2025 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CertificateSubjectTokenSupplier = exports.InvalidConfigurationError = exports.CertificateSourceUnavailableError = exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = void 0;\nconst util_1 = require(\"../util\");\nconst fs = require(\"fs\");\nconst crypto_1 = require(\"crypto\");\nconst https = require(\"https\");\nexports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = 'GOOGLE_API_CERTIFICATE_CONFIG';\n/**\n * Thrown when the certificate source cannot be located or accessed.\n */\nclass CertificateSourceUnavailableError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'CertificateSourceUnavailableError';\n  }\n}\nexports.CertificateSourceUnavailableError = CertificateSourceUnavailableError;\n/**\n * Thrown for invalid configuration that is not related to file availability.\n */\nclass InvalidConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidConfigurationError';\n  }\n}\nexports.InvalidConfigurationError = InvalidConfigurationError;\n/**\n * A subject token supplier that uses a client certificate for authentication.\n * It provides the certificate chain as the subject token for identity federation.\n */\nclass CertificateSubjectTokenSupplier {\n  certificateConfigPath;\n  trustChainPath;\n  cert;\n  key;\n  /**\n   * Initializes a new instance of the CertificateSubjectTokenSupplier.\n   * @param opts The configuration options for the supplier.\n   */\n  constructor(opts) {\n    if (!opts.useDefaultCertificateConfig && !opts.certificateConfigLocation) {\n      throw new InvalidConfigurationError('Either `useDefaultCertificateConfig` must be true or a `certificateConfigLocation` must be provided.');\n    }\n    if (opts.useDefaultCertificateConfig && opts.certificateConfigLocation) {\n      throw new InvalidConfigurationError('Both `useDefaultCertificateConfig` and `certificateConfigLocation` cannot be provided.');\n    }\n    this.trustChainPath = opts.trustChainPath;\n    this.certificateConfigPath = opts.certificateConfigLocation ?? '';\n  }\n  /**\n   * Creates an HTTPS agent configured with the client certificate and private key for mTLS.\n   * @returns An mTLS-configured https.Agent.\n   */\n  async createMtlsHttpsAgent() {\n    if (!this.key || !this.cert) {\n      throw new InvalidConfigurationError('Cannot create mTLS Agent with missing certificate or key');\n    }\n    return new https.Agent({\n      key: this.key,\n      cert: this.cert\n    });\n  }\n  /**\n   * Constructs the subject token, which is the base64-encoded certificate chain.\n   * @returns A promise that resolves with the subject token.\n   */\n  async getSubjectToken() {\n    // The \"subject token\" in this context is the processed certificate chain.\n    this.certificateConfigPath = await this.#resolveCertificateConfigFilePath();\n    const {\n      certPath,\n      keyPath\n    } = await this.#getCertAndKeyPaths();\n    ({\n      cert: this.cert,\n      key: this.key\n    } = await this.#getKeyAndCert(certPath, keyPath));\n    return await this.#processChainFromPaths(this.cert);\n  }\n  /**\n   * Resolves the absolute path to the certificate configuration file\n   * by checking the \"certificate_config_location\" provided in the ADC file,\n   * or the \"GOOGLE_API_CERTIFICATE_CONFIG\" environment variable\n   * or in the default gcloud path.\n   * @param overridePath An optional path to check first.\n   * @returns The resolved file path.\n   */\n  async #resolveCertificateConfigFilePath() {\n    // 1. Check for the override path from constructor options.\n    const overridePath = this.certificateConfigPath;\n    if (overridePath) {\n      if (await (0, util_1.isValidFile)(overridePath)) {\n        return overridePath;\n      }\n      throw new CertificateSourceUnavailableError(`Provided certificate config path is invalid: ${overridePath}`);\n    }\n    // 2. Check the standard environment variable.\n    const envPath = process.env[exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE];\n    if (envPath) {\n      if (await (0, util_1.isValidFile)(envPath)) {\n        return envPath;\n      }\n      throw new CertificateSourceUnavailableError(`Path from environment variable \"${exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}\" is invalid: ${envPath}`);\n    }\n    // 3. Check the well-known gcloud config location.\n    const wellKnownPath = (0, util_1.getWellKnownCertificateConfigFileLocation)();\n    if (await (0, util_1.isValidFile)(wellKnownPath)) {\n      return wellKnownPath;\n    }\n    // 4. If none are found, throw an error.\n    throw new CertificateSourceUnavailableError('Could not find certificate configuration file. Searched override path, ' + `the \"${exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}\" env var, and the gcloud path (${wellKnownPath}).`);\n  }\n  /**\n   * Reads and parses the certificate config JSON file to extract the certificate and key paths.\n   * @returns An object containing the certificate and key paths.\n   */\n  async #getCertAndKeyPaths() {\n    const configPath = this.certificateConfigPath;\n    let fileContents;\n    try {\n      fileContents = await fs.promises.readFile(configPath, 'utf8');\n    } catch (err) {\n      throw new CertificateSourceUnavailableError(`Failed to read certificate config file at: ${configPath}`);\n    }\n    try {\n      const config = JSON.parse(fileContents);\n      const certPath = config?.cert_configs?.workload?.cert_path;\n      const keyPath = config?.cert_configs?.workload?.key_path;\n      if (!certPath || !keyPath) {\n        throw new InvalidConfigurationError(`Certificate config file (${configPath}) is missing required \"cert_path\" or \"key_path\" in the workload config.`);\n      }\n      return {\n        certPath,\n        keyPath\n      };\n    } catch (e) {\n      if (e instanceof InvalidConfigurationError) throw e;\n      throw new InvalidConfigurationError(`Failed to parse certificate config from ${configPath}: ${e.message}`);\n    }\n  }\n  /**\n   * Reads and parses the cert and key files get their content and check valid format.\n   * @returns An object containing the cert content and key content in buffer format.\n   */\n  async #getKeyAndCert(certPath, keyPath) {\n    let cert, key;\n    try {\n      cert = await fs.promises.readFile(certPath);\n      new crypto_1.X509Certificate(cert);\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err);\n      throw new CertificateSourceUnavailableError(`Failed to read certificate file at ${certPath}: ${message}`);\n    }\n    try {\n      key = await fs.promises.readFile(keyPath);\n      (0, crypto_1.createPrivateKey)(key);\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err);\n      throw new CertificateSourceUnavailableError(`Failed to read private key file at ${keyPath}: ${message}`);\n    }\n    return {\n      cert,\n      key\n    };\n  }\n  /**\n   * Reads the leaf certificate and trust chain, combines them,\n   * and returns a JSON array of base64-encoded certificates.\n   * @returns A stringified JSON array of the certificate chain.\n   */\n  async #processChainFromPaths(leafCertBuffer) {\n    const leafCert = new crypto_1.X509Certificate(leafCertBuffer);\n    // If no trust chain is provided, just use the successfully parsed leaf certificate.\n    if (!this.trustChainPath) {\n      return JSON.stringify([leafCert.raw.toString('base64')]);\n    }\n    // Handle the trust chain logic.\n    try {\n      const chainPems = await fs.promises.readFile(this.trustChainPath, 'utf8');\n      const pemBlocks = chainPems.match(/-----BEGIN CERTIFICATE-----[^-]+-----END CERTIFICATE-----/g) ?? [];\n      const chainCerts = pemBlocks.map((pem, index) => {\n        try {\n          return new crypto_1.X509Certificate(pem);\n        } catch (err) {\n          const message = err instanceof Error ? err.message : String(err);\n          // Throw a more precise error if a single certificate in the chain is invalid.\n          throw new InvalidConfigurationError(`Failed to parse certificate at index ${index} in trust chain file ${this.trustChainPath}: ${message}`);\n        }\n      });\n      const leafIndex = chainCerts.findIndex(chainCert => leafCert.raw.equals(chainCert.raw));\n      let finalChain;\n      if (leafIndex === -1) {\n        // Leaf not found, so prepend it to the chain.\n        finalChain = [leafCert, ...chainCerts];\n      } else if (leafIndex === 0) {\n        // Leaf is already the first element, so the chain is correctly ordered.\n        finalChain = chainCerts;\n      } else {\n        // Leaf is in the chain but not at the top, which is invalid.\n        throw new InvalidConfigurationError(`Leaf certificate exists in the trust chain but is not the first entry (found at index ${leafIndex}).`);\n      }\n      return JSON.stringify(finalChain.map(cert => cert.raw.toString('base64')));\n    } catch (err) {\n      // Re-throw our specific configuration errors.\n      if (err instanceof InvalidConfigurationError) throw err;\n      const message = err instanceof Error ? err.message : String(err);\n      throw new CertificateSourceUnavailableError(`Failed to process certificate chain from ${this.trustChainPath}: ${message}`);\n    }\n  }\n}\nexports.CertificateSubjectTokenSupplier = CertificateSubjectTokenSupplier;","map":{"version":3,"names":["Object","defineProperty","exports","value","CertificateSubjectTokenSupplier","InvalidConfigurationError","CertificateSourceUnavailableError","CERTIFICATE_CONFIGURATION_ENV_VARIABLE","util_1","require","fs","crypto_1","https","Error","constructor","message","name","certificateConfigPath","trustChainPath","cert","key","opts","useDefaultCertificateConfig","certificateConfigLocation","createMtlsHttpsAgent","Agent","getSubjectToken","resolveCertificateConfigFilePath","certPath","keyPath","getCertAndKeyPaths","getKeyAndCert","processChainFromPaths","#resolveCertificateConfigFilePath","overridePath","isValidFile","envPath","process","env","wellKnownPath","getWellKnownCertificateConfigFileLocation","#getCertAndKeyPaths","configPath","fileContents","promises","readFile","err","config","JSON","parse","cert_configs","workload","cert_path","key_path","e","#getKeyAndCert","X509Certificate","String","createPrivateKey","#processChainFromPaths","leafCertBuffer","leafCert","stringify","raw","toString","chainPems","pemBlocks","match","chainCerts","map","pem","index","leafIndex","findIndex","chainCert","equals","finalChain"],"sources":["E:/blowpack/frountend/node_modules/google-auth-library/build/src/auth/certificatesubjecttokensupplier.js"],"sourcesContent":["\"use strict\";\n// Copyright 2025 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CertificateSubjectTokenSupplier = exports.InvalidConfigurationError = exports.CertificateSourceUnavailableError = exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = void 0;\nconst util_1 = require(\"../util\");\nconst fs = require(\"fs\");\nconst crypto_1 = require(\"crypto\");\nconst https = require(\"https\");\nexports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = 'GOOGLE_API_CERTIFICATE_CONFIG';\n/**\n * Thrown when the certificate source cannot be located or accessed.\n */\nclass CertificateSourceUnavailableError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'CertificateSourceUnavailableError';\n    }\n}\nexports.CertificateSourceUnavailableError = CertificateSourceUnavailableError;\n/**\n * Thrown for invalid configuration that is not related to file availability.\n */\nclass InvalidConfigurationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InvalidConfigurationError';\n    }\n}\nexports.InvalidConfigurationError = InvalidConfigurationError;\n/**\n * A subject token supplier that uses a client certificate for authentication.\n * It provides the certificate chain as the subject token for identity federation.\n */\nclass CertificateSubjectTokenSupplier {\n    certificateConfigPath;\n    trustChainPath;\n    cert;\n    key;\n    /**\n     * Initializes a new instance of the CertificateSubjectTokenSupplier.\n     * @param opts The configuration options for the supplier.\n     */\n    constructor(opts) {\n        if (!opts.useDefaultCertificateConfig && !opts.certificateConfigLocation) {\n            throw new InvalidConfigurationError('Either `useDefaultCertificateConfig` must be true or a `certificateConfigLocation` must be provided.');\n        }\n        if (opts.useDefaultCertificateConfig && opts.certificateConfigLocation) {\n            throw new InvalidConfigurationError('Both `useDefaultCertificateConfig` and `certificateConfigLocation` cannot be provided.');\n        }\n        this.trustChainPath = opts.trustChainPath;\n        this.certificateConfigPath = opts.certificateConfigLocation ?? '';\n    }\n    /**\n     * Creates an HTTPS agent configured with the client certificate and private key for mTLS.\n     * @returns An mTLS-configured https.Agent.\n     */\n    async createMtlsHttpsAgent() {\n        if (!this.key || !this.cert) {\n            throw new InvalidConfigurationError('Cannot create mTLS Agent with missing certificate or key');\n        }\n        return new https.Agent({ key: this.key, cert: this.cert });\n    }\n    /**\n     * Constructs the subject token, which is the base64-encoded certificate chain.\n     * @returns A promise that resolves with the subject token.\n     */\n    async getSubjectToken() {\n        // The \"subject token\" in this context is the processed certificate chain.\n        this.certificateConfigPath = await this.#resolveCertificateConfigFilePath();\n        const { certPath, keyPath } = await this.#getCertAndKeyPaths();\n        ({ cert: this.cert, key: this.key } = await this.#getKeyAndCert(certPath, keyPath));\n        return await this.#processChainFromPaths(this.cert);\n    }\n    /**\n     * Resolves the absolute path to the certificate configuration file\n     * by checking the \"certificate_config_location\" provided in the ADC file,\n     * or the \"GOOGLE_API_CERTIFICATE_CONFIG\" environment variable\n     * or in the default gcloud path.\n     * @param overridePath An optional path to check first.\n     * @returns The resolved file path.\n     */\n    async #resolveCertificateConfigFilePath() {\n        // 1. Check for the override path from constructor options.\n        const overridePath = this.certificateConfigPath;\n        if (overridePath) {\n            if (await (0, util_1.isValidFile)(overridePath)) {\n                return overridePath;\n            }\n            throw new CertificateSourceUnavailableError(`Provided certificate config path is invalid: ${overridePath}`);\n        }\n        // 2. Check the standard environment variable.\n        const envPath = process.env[exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE];\n        if (envPath) {\n            if (await (0, util_1.isValidFile)(envPath)) {\n                return envPath;\n            }\n            throw new CertificateSourceUnavailableError(`Path from environment variable \"${exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}\" is invalid: ${envPath}`);\n        }\n        // 3. Check the well-known gcloud config location.\n        const wellKnownPath = (0, util_1.getWellKnownCertificateConfigFileLocation)();\n        if (await (0, util_1.isValidFile)(wellKnownPath)) {\n            return wellKnownPath;\n        }\n        // 4. If none are found, throw an error.\n        throw new CertificateSourceUnavailableError('Could not find certificate configuration file. Searched override path, ' +\n            `the \"${exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}\" env var, and the gcloud path (${wellKnownPath}).`);\n    }\n    /**\n     * Reads and parses the certificate config JSON file to extract the certificate and key paths.\n     * @returns An object containing the certificate and key paths.\n     */\n    async #getCertAndKeyPaths() {\n        const configPath = this.certificateConfigPath;\n        let fileContents;\n        try {\n            fileContents = await fs.promises.readFile(configPath, 'utf8');\n        }\n        catch (err) {\n            throw new CertificateSourceUnavailableError(`Failed to read certificate config file at: ${configPath}`);\n        }\n        try {\n            const config = JSON.parse(fileContents);\n            const certPath = config?.cert_configs?.workload?.cert_path;\n            const keyPath = config?.cert_configs?.workload?.key_path;\n            if (!certPath || !keyPath) {\n                throw new InvalidConfigurationError(`Certificate config file (${configPath}) is missing required \"cert_path\" or \"key_path\" in the workload config.`);\n            }\n            return { certPath, keyPath };\n        }\n        catch (e) {\n            if (e instanceof InvalidConfigurationError)\n                throw e;\n            throw new InvalidConfigurationError(`Failed to parse certificate config from ${configPath}: ${e.message}`);\n        }\n    }\n    /**\n     * Reads and parses the cert and key files get their content and check valid format.\n     * @returns An object containing the cert content and key content in buffer format.\n     */\n    async #getKeyAndCert(certPath, keyPath) {\n        let cert, key;\n        try {\n            cert = await fs.promises.readFile(certPath);\n            new crypto_1.X509Certificate(cert);\n        }\n        catch (err) {\n            const message = err instanceof Error ? err.message : String(err);\n            throw new CertificateSourceUnavailableError(`Failed to read certificate file at ${certPath}: ${message}`);\n        }\n        try {\n            key = await fs.promises.readFile(keyPath);\n            (0, crypto_1.createPrivateKey)(key);\n        }\n        catch (err) {\n            const message = err instanceof Error ? err.message : String(err);\n            throw new CertificateSourceUnavailableError(`Failed to read private key file at ${keyPath}: ${message}`);\n        }\n        return { cert, key };\n    }\n    /**\n     * Reads the leaf certificate and trust chain, combines them,\n     * and returns a JSON array of base64-encoded certificates.\n     * @returns A stringified JSON array of the certificate chain.\n     */\n    async #processChainFromPaths(leafCertBuffer) {\n        const leafCert = new crypto_1.X509Certificate(leafCertBuffer);\n        // If no trust chain is provided, just use the successfully parsed leaf certificate.\n        if (!this.trustChainPath) {\n            return JSON.stringify([leafCert.raw.toString('base64')]);\n        }\n        // Handle the trust chain logic.\n        try {\n            const chainPems = await fs.promises.readFile(this.trustChainPath, 'utf8');\n            const pemBlocks = chainPems.match(/-----BEGIN CERTIFICATE-----[^-]+-----END CERTIFICATE-----/g) ?? [];\n            const chainCerts = pemBlocks.map((pem, index) => {\n                try {\n                    return new crypto_1.X509Certificate(pem);\n                }\n                catch (err) {\n                    const message = err instanceof Error ? err.message : String(err);\n                    // Throw a more precise error if a single certificate in the chain is invalid.\n                    throw new InvalidConfigurationError(`Failed to parse certificate at index ${index} in trust chain file ${this.trustChainPath}: ${message}`);\n                }\n            });\n            const leafIndex = chainCerts.findIndex(chainCert => leafCert.raw.equals(chainCert.raw));\n            let finalChain;\n            if (leafIndex === -1) {\n                // Leaf not found, so prepend it to the chain.\n                finalChain = [leafCert, ...chainCerts];\n            }\n            else if (leafIndex === 0) {\n                // Leaf is already the first element, so the chain is correctly ordered.\n                finalChain = chainCerts;\n            }\n            else {\n                // Leaf is in the chain but not at the top, which is invalid.\n                throw new InvalidConfigurationError(`Leaf certificate exists in the trust chain but is not the first entry (found at index ${leafIndex}).`);\n            }\n            return JSON.stringify(finalChain.map(cert => cert.raw.toString('base64')));\n        }\n        catch (err) {\n            // Re-throw our specific configuration errors.\n            if (err instanceof InvalidConfigurationError)\n                throw err;\n            const message = err instanceof Error ? err.message : String(err);\n            throw new CertificateSourceUnavailableError(`Failed to process certificate chain from ${this.trustChainPath}: ${message}`);\n        }\n    }\n}\nexports.CertificateSubjectTokenSupplier = CertificateSubjectTokenSupplier;\n//# sourceMappingURL=certificatesubjecttokensupplier.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,+BAA+B,GAAGF,OAAO,CAACG,yBAAyB,GAAGH,OAAO,CAACI,iCAAiC,GAAGJ,OAAO,CAACK,sCAAsC,GAAG,KAAK,CAAC;AACjL,MAAMC,MAAM,GAAGC,OAAO,CAAC,SAAS,CAAC;AACjC,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAI,CAAC;AACxB,MAAME,QAAQ,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAO,CAAC;AAC9BP,OAAO,CAACK,sCAAsC,GAAG,+BAA+B;AAChF;AACA;AACA;AACA,MAAMD,iCAAiC,SAASO,KAAK,CAAC;EAClDC,WAAWA,CAACC,OAAO,EAAE;IACjB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACC,IAAI,GAAG,mCAAmC;EACnD;AACJ;AACAd,OAAO,CAACI,iCAAiC,GAAGA,iCAAiC;AAC7E;AACA;AACA;AACA,MAAMD,yBAAyB,SAASQ,KAAK,CAAC;EAC1CC,WAAWA,CAACC,OAAO,EAAE;IACjB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACC,IAAI,GAAG,2BAA2B;EAC3C;AACJ;AACAd,OAAO,CAACG,yBAAyB,GAAGA,yBAAyB;AAC7D;AACA;AACA;AACA;AACA,MAAMD,+BAA+B,CAAC;EAClCa,qBAAqB;EACrBC,cAAc;EACdC,IAAI;EACJC,GAAG;EACH;AACJ;AACA;AACA;EACIN,WAAWA,CAACO,IAAI,EAAE;IACd,IAAI,CAACA,IAAI,CAACC,2BAA2B,IAAI,CAACD,IAAI,CAACE,yBAAyB,EAAE;MACtE,MAAM,IAAIlB,yBAAyB,CAAC,sGAAsG,CAAC;IAC/I;IACA,IAAIgB,IAAI,CAACC,2BAA2B,IAAID,IAAI,CAACE,yBAAyB,EAAE;MACpE,MAAM,IAAIlB,yBAAyB,CAAC,wFAAwF,CAAC;IACjI;IACA,IAAI,CAACa,cAAc,GAAGG,IAAI,CAACH,cAAc;IACzC,IAAI,CAACD,qBAAqB,GAAGI,IAAI,CAACE,yBAAyB,IAAI,EAAE;EACrE;EACA;AACJ;AACA;AACA;EACI,MAAMC,oBAAoBA,CAAA,EAAG;IACzB,IAAI,CAAC,IAAI,CAACJ,GAAG,IAAI,CAAC,IAAI,CAACD,IAAI,EAAE;MACzB,MAAM,IAAId,yBAAyB,CAAC,0DAA0D,CAAC;IACnG;IACA,OAAO,IAAIO,KAAK,CAACa,KAAK,CAAC;MAAEL,GAAG,EAAE,IAAI,CAACA,GAAG;MAAED,IAAI,EAAE,IAAI,CAACA;IAAK,CAAC,CAAC;EAC9D;EACA;AACJ;AACA;AACA;EACI,MAAMO,eAAeA,CAAA,EAAG;IACpB;IACA,IAAI,CAACT,qBAAqB,GAAG,MAAM,IAAI,CAAC,CAACU,gCAAgC,CAAC,CAAC;IAC3E,MAAM;MAAEC,QAAQ;MAAEC;IAAQ,CAAC,GAAG,MAAM,IAAI,CAAC,CAACC,kBAAkB,CAAC,CAAC;IAC9D,CAAC;MAAEX,IAAI,EAAE,IAAI,CAACA,IAAI;MAAEC,GAAG,EAAE,IAAI,CAACA;IAAI,CAAC,GAAG,MAAM,IAAI,CAAC,CAACW,aAAa,CAACH,QAAQ,EAAEC,OAAO,CAAC;IAClF,OAAO,MAAM,IAAI,CAAC,CAACG,qBAAqB,CAAC,IAAI,CAACb,IAAI,CAAC;EACvD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAM,CAACQ,gCAAgCM,CAAA,EAAG;IACtC;IACA,MAAMC,YAAY,GAAG,IAAI,CAACjB,qBAAqB;IAC/C,IAAIiB,YAAY,EAAE;MACd,IAAI,MAAM,CAAC,CAAC,EAAE1B,MAAM,CAAC2B,WAAW,EAAED,YAAY,CAAC,EAAE;QAC7C,OAAOA,YAAY;MACvB;MACA,MAAM,IAAI5B,iCAAiC,CAAC,gDAAgD4B,YAAY,EAAE,CAAC;IAC/G;IACA;IACA,MAAME,OAAO,GAAGC,OAAO,CAACC,GAAG,CAACpC,OAAO,CAACK,sCAAsC,CAAC;IAC3E,IAAI6B,OAAO,EAAE;MACT,IAAI,MAAM,CAAC,CAAC,EAAE5B,MAAM,CAAC2B,WAAW,EAAEC,OAAO,CAAC,EAAE;QACxC,OAAOA,OAAO;MAClB;MACA,MAAM,IAAI9B,iCAAiC,CAAC,mCAAmCJ,OAAO,CAACK,sCAAsC,iBAAiB6B,OAAO,EAAE,CAAC;IAC5J;IACA;IACA,MAAMG,aAAa,GAAG,CAAC,CAAC,EAAE/B,MAAM,CAACgC,yCAAyC,EAAE,CAAC;IAC7E,IAAI,MAAM,CAAC,CAAC,EAAEhC,MAAM,CAAC2B,WAAW,EAAEI,aAAa,CAAC,EAAE;MAC9C,OAAOA,aAAa;IACxB;IACA;IACA,MAAM,IAAIjC,iCAAiC,CAAC,yEAAyE,GACjH,QAAQJ,OAAO,CAACK,sCAAsC,mCAAmCgC,aAAa,IAAI,CAAC;EACnH;EACA;AACJ;AACA;AACA;EACI,MAAM,CAACT,kBAAkBW,CAAA,EAAG;IACxB,MAAMC,UAAU,GAAG,IAAI,CAACzB,qBAAqB;IAC7C,IAAI0B,YAAY;IAChB,IAAI;MACAA,YAAY,GAAG,MAAMjC,EAAE,CAACkC,QAAQ,CAACC,QAAQ,CAACH,UAAU,EAAE,MAAM,CAAC;IACjE,CAAC,CACD,OAAOI,GAAG,EAAE;MACR,MAAM,IAAIxC,iCAAiC,CAAC,8CAA8CoC,UAAU,EAAE,CAAC;IAC3G;IACA,IAAI;MACA,MAAMK,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACN,YAAY,CAAC;MACvC,MAAMf,QAAQ,GAAGmB,MAAM,EAAEG,YAAY,EAAEC,QAAQ,EAAEC,SAAS;MAC1D,MAAMvB,OAAO,GAAGkB,MAAM,EAAEG,YAAY,EAAEC,QAAQ,EAAEE,QAAQ;MACxD,IAAI,CAACzB,QAAQ,IAAI,CAACC,OAAO,EAAE;QACvB,MAAM,IAAIxB,yBAAyB,CAAC,4BAA4BqC,UAAU,yEAAyE,CAAC;MACxJ;MACA,OAAO;QAAEd,QAAQ;QAAEC;MAAQ,CAAC;IAChC,CAAC,CACD,OAAOyB,CAAC,EAAE;MACN,IAAIA,CAAC,YAAYjD,yBAAyB,EACtC,MAAMiD,CAAC;MACX,MAAM,IAAIjD,yBAAyB,CAAC,2CAA2CqC,UAAU,KAAKY,CAAC,CAACvC,OAAO,EAAE,CAAC;IAC9G;EACJ;EACA;AACJ;AACA;AACA;EACI,MAAM,CAACgB,aAAawB,CAAC3B,QAAQ,EAAEC,OAAO,EAAE;IACpC,IAAIV,IAAI,EAAEC,GAAG;IACb,IAAI;MACAD,IAAI,GAAG,MAAMT,EAAE,CAACkC,QAAQ,CAACC,QAAQ,CAACjB,QAAQ,CAAC;MAC3C,IAAIjB,QAAQ,CAAC6C,eAAe,CAACrC,IAAI,CAAC;IACtC,CAAC,CACD,OAAO2B,GAAG,EAAE;MACR,MAAM/B,OAAO,GAAG+B,GAAG,YAAYjC,KAAK,GAAGiC,GAAG,CAAC/B,OAAO,GAAG0C,MAAM,CAACX,GAAG,CAAC;MAChE,MAAM,IAAIxC,iCAAiC,CAAC,sCAAsCsB,QAAQ,KAAKb,OAAO,EAAE,CAAC;IAC7G;IACA,IAAI;MACAK,GAAG,GAAG,MAAMV,EAAE,CAACkC,QAAQ,CAACC,QAAQ,CAAChB,OAAO,CAAC;MACzC,CAAC,CAAC,EAAElB,QAAQ,CAAC+C,gBAAgB,EAAEtC,GAAG,CAAC;IACvC,CAAC,CACD,OAAO0B,GAAG,EAAE;MACR,MAAM/B,OAAO,GAAG+B,GAAG,YAAYjC,KAAK,GAAGiC,GAAG,CAAC/B,OAAO,GAAG0C,MAAM,CAACX,GAAG,CAAC;MAChE,MAAM,IAAIxC,iCAAiC,CAAC,sCAAsCuB,OAAO,KAAKd,OAAO,EAAE,CAAC;IAC5G;IACA,OAAO;MAAEI,IAAI;MAAEC;IAAI,CAAC;EACxB;EACA;AACJ;AACA;AACA;AACA;EACI,MAAM,CAACY,qBAAqB2B,CAACC,cAAc,EAAE;IACzC,MAAMC,QAAQ,GAAG,IAAIlD,QAAQ,CAAC6C,eAAe,CAACI,cAAc,CAAC;IAC7D;IACA,IAAI,CAAC,IAAI,CAAC1C,cAAc,EAAE;MACtB,OAAO8B,IAAI,CAACc,SAAS,CAAC,CAACD,QAAQ,CAACE,GAAG,CAACC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC5D;IACA;IACA,IAAI;MACA,MAAMC,SAAS,GAAG,MAAMvD,EAAE,CAACkC,QAAQ,CAACC,QAAQ,CAAC,IAAI,CAAC3B,cAAc,EAAE,MAAM,CAAC;MACzE,MAAMgD,SAAS,GAAGD,SAAS,CAACE,KAAK,CAAC,4DAA4D,CAAC,IAAI,EAAE;MACrG,MAAMC,UAAU,GAAGF,SAAS,CAACG,GAAG,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAK;QAC7C,IAAI;UACA,OAAO,IAAI5D,QAAQ,CAAC6C,eAAe,CAACc,GAAG,CAAC;QAC5C,CAAC,CACD,OAAOxB,GAAG,EAAE;UACR,MAAM/B,OAAO,GAAG+B,GAAG,YAAYjC,KAAK,GAAGiC,GAAG,CAAC/B,OAAO,GAAG0C,MAAM,CAACX,GAAG,CAAC;UAChE;UACA,MAAM,IAAIzC,yBAAyB,CAAC,wCAAwCkE,KAAK,wBAAwB,IAAI,CAACrD,cAAc,KAAKH,OAAO,EAAE,CAAC;QAC/I;MACJ,CAAC,CAAC;MACF,MAAMyD,SAAS,GAAGJ,UAAU,CAACK,SAAS,CAACC,SAAS,IAAIb,QAAQ,CAACE,GAAG,CAACY,MAAM,CAACD,SAAS,CAACX,GAAG,CAAC,CAAC;MACvF,IAAIa,UAAU;MACd,IAAIJ,SAAS,KAAK,CAAC,CAAC,EAAE;QAClB;QACAI,UAAU,GAAG,CAACf,QAAQ,EAAE,GAAGO,UAAU,CAAC;MAC1C,CAAC,MACI,IAAII,SAAS,KAAK,CAAC,EAAE;QACtB;QACAI,UAAU,GAAGR,UAAU;MAC3B,CAAC,MACI;QACD;QACA,MAAM,IAAI/D,yBAAyB,CAAC,yFAAyFmE,SAAS,IAAI,CAAC;MAC/I;MACA,OAAOxB,IAAI,CAACc,SAAS,CAACc,UAAU,CAACP,GAAG,CAAClD,IAAI,IAAIA,IAAI,CAAC4C,GAAG,CAACC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC9E,CAAC,CACD,OAAOlB,GAAG,EAAE;MACR;MACA,IAAIA,GAAG,YAAYzC,yBAAyB,EACxC,MAAMyC,GAAG;MACb,MAAM/B,OAAO,GAAG+B,GAAG,YAAYjC,KAAK,GAAGiC,GAAG,CAAC/B,OAAO,GAAG0C,MAAM,CAACX,GAAG,CAAC;MAChE,MAAM,IAAIxC,iCAAiC,CAAC,4CAA4C,IAAI,CAACY,cAAc,KAAKH,OAAO,EAAE,CAAC;IAC9H;EACJ;AACJ;AACAb,OAAO,CAACE,+BAA+B,GAAGA,+BAA+B","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}