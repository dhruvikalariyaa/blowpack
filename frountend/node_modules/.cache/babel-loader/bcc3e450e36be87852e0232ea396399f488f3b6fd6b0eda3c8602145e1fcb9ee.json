{"ast":null,"code":"\"use strict\";\n\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst gaxios_1 = require(\"gaxios\");\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\nclass DownscopedClient extends authclient_1.AuthClient {\n  authClient;\n  credentialAccessBoundary;\n  cachedDownscopedAccessToken;\n  stsCredential;\n  /**\n   * Instantiates a downscoped client object using the provided source\n   * AuthClient and credential access boundary rules.\n   * To downscope permissions of a source AuthClient, a Credential Access\n   * Boundary that specifies which resources the new credential can access, as\n   * well as an upper bound on the permissions that are available on each\n   * resource, has to be defined. A downscoped client can then be instantiated\n   * using the source AuthClient and the Credential Access Boundary.\n   * @param options the {@link DownscopedClientOptions `DownscopedClientOptions`} to use. Passing an `AuthClient` directly is **@DEPRECATED**.\n   * @param credentialAccessBoundary **@DEPRECATED**. Provide a {@link DownscopedClientOptions `DownscopedClientOptions`} object in the first parameter instead.\n   */\n  constructor(\n  /**\n   * AuthClient is for backwards-compatibility.\n   */\n  options,\n  /**\n   * @deprecated - provide a {@link DownscopedClientOptions `DownscopedClientOptions`} object in the first parameter instead\n   */\n  credentialAccessBoundary = {\n    accessBoundary: {\n      accessBoundaryRules: []\n    }\n  }) {\n    super(options instanceof authclient_1.AuthClient ? {} : options);\n    if (options instanceof authclient_1.AuthClient) {\n      this.authClient = options;\n      this.credentialAccessBoundary = credentialAccessBoundary;\n    } else {\n      this.authClient = options.authClient;\n      this.credentialAccessBoundary = options.credentialAccessBoundary;\n    }\n    // Check 1-10 Access Boundary Rules are defined within Credential Access\n    // Boundary.\n    if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n      throw new Error('At least one access boundary rule needs to be defined.');\n    } else if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n      throw new Error('The provided access boundary has more than ' + `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n    }\n    // Check at least one permission should be defined in each Access Boundary\n    // Rule.\n    for (const rule of this.credentialAccessBoundary.accessBoundary.accessBoundaryRules) {\n      if (rule.availablePermissions.length === 0) {\n        throw new Error('At least one permission should be defined in access boundary rules.');\n      }\n    }\n    this.stsCredential = new sts.StsCredentials({\n      tokenExchangeEndpoint: `https://sts.${this.universeDomain}/v1/token`\n    });\n    this.cachedDownscopedAccessToken = null;\n  }\n  /**\n   * Provides a mechanism to inject Downscoped access tokens directly.\n   * The expiry_date field is required to facilitate determination of the token\n   * expiration which would make it easier for the token consumer to handle.\n   * @param credentials The Credentials object to set on the current client.\n   */\n  setCredentials(credentials) {\n    if (!credentials.expiry_date) {\n      throw new Error('The access token expiry_date field is missing in the provided ' + 'credentials.');\n    }\n    super.setCredentials(credentials);\n    this.cachedDownscopedAccessToken = credentials;\n  }\n  async getAccessToken() {\n    // If the cached access token is unavailable or expired, force refresh.\n    // The Downscoped access token will be returned in\n    // DownscopedAccessTokenResponse format.\n    if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {\n      await this.refreshAccessTokenAsync();\n    }\n    // Return Downscoped access token in DownscopedAccessTokenResponse format.\n    return {\n      token: this.cachedDownscopedAccessToken.access_token,\n      expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n      res: this.cachedDownscopedAccessToken.res\n    };\n  }\n  /**\n   * The main authentication interface. It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * The result has the form:\n   * { authorization: 'Bearer <access_token_value>' }\n   */\n  async getRequestHeaders() {\n    const accessTokenResponse = await this.getAccessToken();\n    const headers = new Headers({\n      authorization: `Bearer ${accessTokenResponse.token}`\n    });\n    return this.addSharedMetadataHeaders(headers);\n  }\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure\n   * @return A promise that resolves with the successful response.\n   */\n  async requestAsync(opts, reAuthRetried = false) {\n    let response;\n    try {\n      const requestHeaders = await this.getRequestHeaders();\n      opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);\n      this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);\n      response = await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - forceRefreshOnFailure is true\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n          await this.refreshAccessTokenAsync();\n          return await this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return response;\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * GCP access tokens are retrieved from authclient object/source credential.\n   * Then GCP access tokens are exchanged for downscoped access tokens via the\n   * token exchange endpoint.\n   * @return A promise that resolves with the fresh downscoped access token.\n   */\n  async refreshAccessTokenAsync() {\n    // Retrieve GCP access token from source credential.\n    const subjectToken = (await this.authClient.getAccessToken()).token;\n    // Construct the STS credentials options.\n    const stsCredentialsOptions = {\n      grantType: STS_GRANT_TYPE,\n      requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n      subjectToken: subjectToken,\n      subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n    };\n    // Exchange the source AuthClient access token for a Downscoped access\n    // token.\n    const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n    /**\n     * The STS endpoint will only return the expiration time for the downscoped\n     * access token if the original access token represents a service account.\n     * The downscoped token's expiration time will always match the source\n     * credential expiration. When no expires_in is returned, we can copy the\n     * source credential's expiration time.\n     */\n    const sourceCredExpireDate = this.authClient.credentials?.expiry_date || null;\n    const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate;\n    // Save response in cached access token.\n    this.cachedDownscopedAccessToken = {\n      access_token: stsResponse.access_token,\n      expiry_date: expiryDate,\n      res: stsResponse.res\n    };\n    // Save credentials.\n    this.credentials = {};\n    Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n    delete this.credentials.res;\n    // Trigger tokens event to notify external listeners.\n    this.emit('tokens', {\n      refresh_token: null,\n      expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n      access_token: this.cachedDownscopedAccessToken.access_token,\n      token_type: 'Bearer',\n      id_token: null\n    });\n    // Return the cached access token.\n    return this.cachedDownscopedAccessToken;\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param downscopedAccessToken The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n  isExpired(downscopedAccessToken) {\n    const now = new Date().getTime();\n    return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n}\nexports.DownscopedClient = DownscopedClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","DownscopedClient","EXPIRATION_TIME_OFFSET","MAX_ACCESS_BOUNDARY_RULES_COUNT","gaxios_1","require","stream","authclient_1","sts","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","STS_SUBJECT_TOKEN_TYPE","AuthClient","authClient","credentialAccessBoundary","cachedDownscopedAccessToken","stsCredential","constructor","options","accessBoundary","accessBoundaryRules","length","Error","rule","availablePermissions","StsCredentials","tokenExchangeEndpoint","universeDomain","setCredentials","credentials","expiry_date","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","expirationTime","res","getRequestHeaders","accessTokenResponse","headers","Headers","authorization","addSharedMetadataHeaders","request","opts","callback","requestAsync","then","r","e","response","reAuthRetried","requestHeaders","Gaxios","mergeHeaders","addUserProjectAndAuthHeaders","transporter","statusCode","status","isReadableStream","config","data","Readable","isAuthErr","forceRefreshOnFailure","subjectToken","stsCredentialsOptions","grantType","requestedTokenType","subjectTokenType","stsResponse","exchangeToken","undefined","sourceCredExpireDate","expiryDate","expires_in","Date","getTime","assign","emit","refresh_token","token_type","id_token","downscopedAccessToken","now","eagerRefreshThresholdMillis"],"sources":["E:/blowpack/frountend/node_modules/google-auth-library/build/src/auth/downscopedclient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst gaxios_1 = require(\"gaxios\");\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\nclass DownscopedClient extends authclient_1.AuthClient {\n    authClient;\n    credentialAccessBoundary;\n    cachedDownscopedAccessToken;\n    stsCredential;\n    /**\n     * Instantiates a downscoped client object using the provided source\n     * AuthClient and credential access boundary rules.\n     * To downscope permissions of a source AuthClient, a Credential Access\n     * Boundary that specifies which resources the new credential can access, as\n     * well as an upper bound on the permissions that are available on each\n     * resource, has to be defined. A downscoped client can then be instantiated\n     * using the source AuthClient and the Credential Access Boundary.\n     * @param options the {@link DownscopedClientOptions `DownscopedClientOptions`} to use. Passing an `AuthClient` directly is **@DEPRECATED**.\n     * @param credentialAccessBoundary **@DEPRECATED**. Provide a {@link DownscopedClientOptions `DownscopedClientOptions`} object in the first parameter instead.\n     */\n    constructor(\n    /**\n     * AuthClient is for backwards-compatibility.\n     */\n    options, \n    /**\n     * @deprecated - provide a {@link DownscopedClientOptions `DownscopedClientOptions`} object in the first parameter instead\n     */\n    credentialAccessBoundary = {\n        accessBoundary: {\n            accessBoundaryRules: [],\n        },\n    }) {\n        super(options instanceof authclient_1.AuthClient ? {} : options);\n        if (options instanceof authclient_1.AuthClient) {\n            this.authClient = options;\n            this.credentialAccessBoundary = credentialAccessBoundary;\n        }\n        else {\n            this.authClient = options.authClient;\n            this.credentialAccessBoundary = options.credentialAccessBoundary;\n        }\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\n        // Boundary.\n        if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules\n            .length === 0) {\n            throw new Error('At least one access boundary rule needs to be defined.');\n        }\n        else if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length >\n            exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n            throw new Error('The provided access boundary has more than ' +\n                `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n        }\n        // Check at least one permission should be defined in each Access Boundary\n        // Rule.\n        for (const rule of this.credentialAccessBoundary.accessBoundary\n            .accessBoundaryRules) {\n            if (rule.availablePermissions.length === 0) {\n                throw new Error('At least one permission should be defined in access boundary rules.');\n            }\n        }\n        this.stsCredential = new sts.StsCredentials({\n            tokenExchangeEndpoint: `https://sts.${this.universeDomain}/v1/token`,\n        });\n        this.cachedDownscopedAccessToken = null;\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * The expiry_date field is required to facilitate determination of the token\n     * expiration which would make it easier for the token consumer to handle.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        if (!credentials.expiry_date) {\n            throw new Error('The access token expiry_date field is missing in the provided ' +\n                'credentials.');\n        }\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in\n        // DownscopedAccessTokenResponse format.\n        if (!this.cachedDownscopedAccessToken ||\n            this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n            res: this.cachedDownscopedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = new Headers({\n            authorization: `Bearer ${accessTokenResponse.token}`,\n        });\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, reAuthRetried = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);\n            this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!reAuthRetried &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n    async refreshAccessTokenAsync() {\n        // Retrieve GCP access token from source credential.\n        const subjectToken = (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE,\n        };\n        // Exchange the source AuthClient access token for a Downscoped access\n        // token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        /**\n         * The STS endpoint will only return the expiration time for the downscoped\n         * access token if the original access token represents a service account.\n         * The downscoped token's expiration time will always match the source\n         * credential expiration. When no expires_in is returned, we can copy the\n         * source credential's expiration time.\n         */\n        const sourceCredExpireDate = this.authClient.credentials?.expiry_date || null;\n        const expiryDate = stsResponse.expires_in\n            ? new Date().getTime() + stsResponse.expires_in * 1000\n            : sourceCredExpireDate;\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: expiryDate,\n            res: stsResponse.res,\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date\n            ? now >=\n                downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient;\n//# sourceMappingURL=downscopedclient.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}