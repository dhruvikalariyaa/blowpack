{"ast":null,"code":"import{useState,useCallback}from'react';import{handleApiError,retryRequest}from'../utils/errorHandler';export const useApi=()=>{const[loading,setLoading]=useState(false);const[error,setError]=useState(null);const makeRequest=useCallback(async function(requestFn){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{showLoading=true,retry=true,maxRetries=3,onError=null}=options;try{if(showLoading)setLoading(true);setError(null);const response=await(retry?retryRequest(requestFn,maxRetries):requestFn());return response;}catch(err){const errorInfo=handleApiError(err,err.response);setError(errorInfo);if(onError){onError(errorInfo);}throw errorInfo;}finally{if(showLoading)setLoading(false);}},[]);const clearError=useCallback(()=>{setError(null);},[]);return{loading,error,makeRequest,clearError};};// Hook for handling 429 errors specifically\nexport const useRateLimitHandler=()=>{const[isRateLimited,setIsRateLimited]=useState(false);const[retryAfter,setRetryAfter]=useState(null);const handleRateLimit=useCallback(error=>{if(error.status===429){setIsRateLimited(true);setRetryAfter(error.retryAfter);// Auto-clear rate limit after retry time\nif(error.retryAfter){setTimeout(()=>{setIsRateLimited(false);setRetryAfter(null);},error.retryAfter*1000);}}},[]);const clearRateLimit=useCallback(()=>{setIsRateLimited(false);setRetryAfter(null);},[]);return{isRateLimited,retryAfter,handleRateLimit,clearRateLimit};};","map":{"version":3,"names":["useState","useCallback","handleApiError","retryRequest","useApi","loading","setLoading","error","setError","makeRequest","requestFn","options","arguments","length","undefined","showLoading","retry","maxRetries","onError","response","err","errorInfo","clearError","useRateLimitHandler","isRateLimited","setIsRateLimited","retryAfter","setRetryAfter","handleRateLimit","status","setTimeout","clearRateLimit"],"sources":["E:/blowpack/frountend/src/hooks/useApi.js"],"sourcesContent":["import { useState, useCallback } from 'react';\r\nimport { handleApiError, retryRequest } from '../utils/errorHandler';\r\n\r\nexport const useApi = () => {\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  const makeRequest = useCallback(async (requestFn, options = {}) => {\r\n    const { \r\n      showLoading = true, \r\n      retry = true, \r\n      maxRetries = 3,\r\n      onError = null \r\n    } = options;\r\n\r\n    try {\r\n      if (showLoading) setLoading(true);\r\n      setError(null);\r\n\r\n      const response = await (retry ? retryRequest(requestFn, maxRetries) : requestFn());\r\n      \r\n      return response;\r\n    } catch (err) {\r\n      const errorInfo = handleApiError(err, err.response);\r\n      setError(errorInfo);\r\n      \r\n      if (onError) {\r\n        onError(errorInfo);\r\n      }\r\n      \r\n      throw errorInfo;\r\n    } finally {\r\n      if (showLoading) setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  const clearError = useCallback(() => {\r\n    setError(null);\r\n  }, []);\r\n\r\n  return {\r\n    loading,\r\n    error,\r\n    makeRequest,\r\n    clearError\r\n  };\r\n};\r\n\r\n// Hook for handling 429 errors specifically\r\nexport const useRateLimitHandler = () => {\r\n  const [isRateLimited, setIsRateLimited] = useState(false);\r\n  const [retryAfter, setRetryAfter] = useState(null);\r\n\r\n  const handleRateLimit = useCallback((error) => {\r\n    if (error.status === 429) {\r\n      setIsRateLimited(true);\r\n      setRetryAfter(error.retryAfter);\r\n      \r\n      // Auto-clear rate limit after retry time\r\n      if (error.retryAfter) {\r\n        setTimeout(() => {\r\n          setIsRateLimited(false);\r\n          setRetryAfter(null);\r\n        }, error.retryAfter * 1000);\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  const clearRateLimit = useCallback(() => {\r\n    setIsRateLimited(false);\r\n    setRetryAfter(null);\r\n  }, []);\r\n\r\n  return {\r\n    isRateLimited,\r\n    retryAfter,\r\n    handleRateLimit,\r\n    clearRateLimit\r\n  };\r\n};\r\n"],"mappings":"AAAA,OAASA,QAAQ,CAAEC,WAAW,KAAQ,OAAO,CAC7C,OAASC,cAAc,CAAEC,YAAY,KAAQ,uBAAuB,CAEpE,MAAO,MAAM,CAAAC,MAAM,CAAGA,CAAA,GAAM,CAC1B,KAAM,CAACC,OAAO,CAAEC,UAAU,CAAC,CAAGN,QAAQ,CAAC,KAAK,CAAC,CAC7C,KAAM,CAACO,KAAK,CAAEC,QAAQ,CAAC,CAAGR,QAAQ,CAAC,IAAI,CAAC,CAExC,KAAM,CAAAS,WAAW,CAAGR,WAAW,CAAC,eAAOS,SAAS,CAAmB,IAAjB,CAAAC,OAAO,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CAC5D,KAAM,CACJG,WAAW,CAAG,IAAI,CAClBC,KAAK,CAAG,IAAI,CACZC,UAAU,CAAG,CAAC,CACdC,OAAO,CAAG,IACZ,CAAC,CAAGP,OAAO,CAEX,GAAI,CACF,GAAII,WAAW,CAAET,UAAU,CAAC,IAAI,CAAC,CACjCE,QAAQ,CAAC,IAAI,CAAC,CAEd,KAAM,CAAAW,QAAQ,CAAG,MAAOH,KAAK,CAAGb,YAAY,CAACO,SAAS,CAAEO,UAAU,CAAC,CAAGP,SAAS,CAAC,CAAC,CAAC,CAElF,MAAO,CAAAS,QAAQ,CACjB,CAAE,MAAOC,GAAG,CAAE,CACZ,KAAM,CAAAC,SAAS,CAAGnB,cAAc,CAACkB,GAAG,CAAEA,GAAG,CAACD,QAAQ,CAAC,CACnDX,QAAQ,CAACa,SAAS,CAAC,CAEnB,GAAIH,OAAO,CAAE,CACXA,OAAO,CAACG,SAAS,CAAC,CACpB,CAEA,KAAM,CAAAA,SAAS,CACjB,CAAC,OAAS,CACR,GAAIN,WAAW,CAAET,UAAU,CAAC,KAAK,CAAC,CACpC,CACF,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAAgB,UAAU,CAAGrB,WAAW,CAAC,IAAM,CACnCO,QAAQ,CAAC,IAAI,CAAC,CAChB,CAAC,CAAE,EAAE,CAAC,CAEN,MAAO,CACLH,OAAO,CACPE,KAAK,CACLE,WAAW,CACXa,UACF,CAAC,CACH,CAAC,CAED;AACA,MAAO,MAAM,CAAAC,mBAAmB,CAAGA,CAAA,GAAM,CACvC,KAAM,CAACC,aAAa,CAAEC,gBAAgB,CAAC,CAAGzB,QAAQ,CAAC,KAAK,CAAC,CACzD,KAAM,CAAC0B,UAAU,CAAEC,aAAa,CAAC,CAAG3B,QAAQ,CAAC,IAAI,CAAC,CAElD,KAAM,CAAA4B,eAAe,CAAG3B,WAAW,CAAEM,KAAK,EAAK,CAC7C,GAAIA,KAAK,CAACsB,MAAM,GAAK,GAAG,CAAE,CACxBJ,gBAAgB,CAAC,IAAI,CAAC,CACtBE,aAAa,CAACpB,KAAK,CAACmB,UAAU,CAAC,CAE/B;AACA,GAAInB,KAAK,CAACmB,UAAU,CAAE,CACpBI,UAAU,CAAC,IAAM,CACfL,gBAAgB,CAAC,KAAK,CAAC,CACvBE,aAAa,CAAC,IAAI,CAAC,CACrB,CAAC,CAAEpB,KAAK,CAACmB,UAAU,CAAG,IAAI,CAAC,CAC7B,CACF,CACF,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAAK,cAAc,CAAG9B,WAAW,CAAC,IAAM,CACvCwB,gBAAgB,CAAC,KAAK,CAAC,CACvBE,aAAa,CAAC,IAAI,CAAC,CACrB,CAAC,CAAE,EAAE,CAAC,CAEN,MAAO,CACLH,aAAa,CACbE,UAAU,CACVE,eAAe,CACfG,cACF,CAAC,CACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}